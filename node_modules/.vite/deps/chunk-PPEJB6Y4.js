import {
  Attributor,
  Block,
  BlockBlot$1,
  BlockEmbed,
  ClassAttributor$1,
  ContainerBlot$1,
  EmbedBlot$1,
  LeafBlot$1,
  ParentBlot$1,
  Quill,
  Range,
  Scope,
  ScrollBlot$1,
  StyleAttributor$1,
  Text,
  TextBlot$1,
  blockDelta,
  break_default,
  bubbleFormats,
  cloneDeep_default,
  container_default,
  cursor_default,
  embed_default,
  emitter_default,
  escapeText,
  init_block,
  init_break,
  init_container,
  init_cursor,
  init_embed,
  init_emitter,
  init_inline,
  init_lodash,
  init_logger,
  init_module,
  init_parchment,
  init_quill,
  init_selection,
  init_table,
  init_text,
  init_theme,
  inline_default,
  isEqual_default,
  logger_default,
  merge_default,
  module_default,
  parchment_exports,
  require_Delta,
  table_default,
  theme_default
} from "./chunk-UMK674QI.js";
import {
  __esm,
  __export,
  __publicField,
  __toESM
} from "./chunk-EWTE5DHJ.js";

// node_modules/quill/blots/scroll.js
function isLine(blot) {
  return blot instanceof Block || blot instanceof BlockEmbed;
}
function isUpdatable(blot) {
  return typeof blot.updateContent === "function";
}
function insertInlineContents(parent, index, inlineContents) {
  inlineContents.reduce((index2, op) => {
    const length = import_quill_delta.Op.length(op);
    let attributes = op.attributes || {};
    if (op.insert != null) {
      if (typeof op.insert === "string") {
        const text = op.insert;
        parent.insertAt(index2, text);
        const [leaf] = parent.descendant(LeafBlot$1, index2);
        const formats = bubbleFormats(leaf);
        attributes = import_quill_delta.AttributeMap.diff(formats, attributes) || {};
      } else if (typeof op.insert === "object") {
        const key = Object.keys(op.insert)[0];
        if (key == null) return index2;
        parent.insertAt(index2, key, op.insert[key]);
        const isInlineEmbed = parent.scroll.query(key, Scope.INLINE) != null;
        if (isInlineEmbed) {
          const [leaf] = parent.descendant(LeafBlot$1, index2);
          const formats = bubbleFormats(leaf);
          attributes = import_quill_delta.AttributeMap.diff(formats, attributes) || {};
        }
      }
    }
    Object.keys(attributes).forEach((key) => {
      parent.formatAt(index2, length, key, attributes[key]);
    });
    return index2 + length;
  }, index);
}
var import_quill_delta, Scroll, scroll_default;
var init_scroll = __esm({
  "node_modules/quill/blots/scroll.js"() {
    init_parchment();
    import_quill_delta = __toESM(require_Delta(), 1);
    init_emitter();
    init_block();
    init_break();
    init_container();
    Scroll = class extends ScrollBlot$1 {
      constructor(registry, domNode, _ref) {
        let {
          emitter
        } = _ref;
        super(registry, domNode);
        this.emitter = emitter;
        this.batch = false;
        this.optimize();
        this.enable();
        this.domNode.addEventListener("dragstart", (e) => this.handleDragStart(e));
      }
      batchStart() {
        if (!Array.isArray(this.batch)) {
          this.batch = [];
        }
      }
      batchEnd() {
        if (!this.batch) return;
        const mutations = this.batch;
        this.batch = false;
        this.update(mutations);
      }
      emitMount(blot) {
        this.emitter.emit(emitter_default.events.SCROLL_BLOT_MOUNT, blot);
      }
      emitUnmount(blot) {
        this.emitter.emit(emitter_default.events.SCROLL_BLOT_UNMOUNT, blot);
      }
      emitEmbedUpdate(blot, change) {
        this.emitter.emit(emitter_default.events.SCROLL_EMBED_UPDATE, blot, change);
      }
      deleteAt(index, length) {
        const [first, offset] = this.line(index);
        const [last] = this.line(index + length);
        super.deleteAt(index, length);
        if (last != null && first !== last && offset > 0) {
          if (first instanceof BlockEmbed || last instanceof BlockEmbed) {
            this.optimize();
            return;
          }
          const ref = last.children.head instanceof break_default ? null : last.children.head;
          first.moveChildren(last, ref);
          first.remove();
        }
        this.optimize();
      }
      enable() {
        let enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        this.domNode.setAttribute("contenteditable", enabled ? "true" : "false");
      }
      formatAt(index, length, format, value) {
        super.formatAt(index, length, format, value);
        this.optimize();
      }
      insertAt(index, value, def) {
        if (index >= this.length()) {
          if (def == null || this.scroll.query(value, Scope.BLOCK) == null) {
            const blot = this.scroll.create(this.statics.defaultChild.blotName);
            this.appendChild(blot);
            if (def == null && value.endsWith("\n")) {
              blot.insertAt(0, value.slice(0, -1), def);
            } else {
              blot.insertAt(0, value, def);
            }
          } else {
            const embed = this.scroll.create(value, def);
            this.appendChild(embed);
          }
        } else {
          super.insertAt(index, value, def);
        }
        this.optimize();
      }
      insertBefore(blot, ref) {
        if (blot.statics.scope === Scope.INLINE_BLOT) {
          const wrapper = this.scroll.create(this.statics.defaultChild.blotName);
          wrapper.appendChild(blot);
          super.insertBefore(wrapper, ref);
        } else {
          super.insertBefore(blot, ref);
        }
      }
      insertContents(index, delta) {
        const renderBlocks = this.deltaToRenderBlocks(delta.concat(new import_quill_delta.default().insert("\n")));
        const last = renderBlocks.pop();
        if (last == null) return;
        this.batchStart();
        const first = renderBlocks.shift();
        if (first) {
          const shouldInsertNewlineChar = first.type === "block" && (first.delta.length() === 0 || !this.descendant(BlockEmbed, index)[0] && index < this.length());
          const delta2 = first.type === "block" ? first.delta : new import_quill_delta.default().insert({
            [first.key]: first.value
          });
          insertInlineContents(this, index, delta2);
          const newlineCharLength = first.type === "block" ? 1 : 0;
          const lineEndIndex = index + delta2.length() + newlineCharLength;
          if (shouldInsertNewlineChar) {
            this.insertAt(lineEndIndex - 1, "\n");
          }
          const formats = bubbleFormats(this.line(index)[0]);
          const attributes = import_quill_delta.AttributeMap.diff(formats, first.attributes) || {};
          Object.keys(attributes).forEach((name) => {
            this.formatAt(lineEndIndex - 1, 1, name, attributes[name]);
          });
          index = lineEndIndex;
        }
        let [refBlot, refBlotOffset] = this.children.find(index);
        if (renderBlocks.length) {
          if (refBlot) {
            refBlot = refBlot.split(refBlotOffset);
            refBlotOffset = 0;
          }
          renderBlocks.forEach((renderBlock) => {
            if (renderBlock.type === "block") {
              const block = this.createBlock(renderBlock.attributes, refBlot || void 0);
              insertInlineContents(block, 0, renderBlock.delta);
            } else {
              const blockEmbed = this.create(renderBlock.key, renderBlock.value);
              this.insertBefore(blockEmbed, refBlot || void 0);
              Object.keys(renderBlock.attributes).forEach((name) => {
                blockEmbed.format(name, renderBlock.attributes[name]);
              });
            }
          });
        }
        if (last.type === "block" && last.delta.length()) {
          const offset = refBlot ? refBlot.offset(refBlot.scroll) + refBlotOffset : this.length();
          insertInlineContents(this, offset, last.delta);
        }
        this.batchEnd();
        this.optimize();
      }
      isEnabled() {
        return this.domNode.getAttribute("contenteditable") === "true";
      }
      leaf(index) {
        const last = this.path(index).pop();
        if (!last) {
          return [null, -1];
        }
        const [blot, offset] = last;
        return blot instanceof LeafBlot$1 ? [blot, offset] : [null, -1];
      }
      line(index) {
        if (index === this.length()) {
          return this.line(index - 1);
        }
        return this.descendant(isLine, index);
      }
      lines() {
        let index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.MAX_VALUE;
        const getLines = (blot, blotIndex, blotLength) => {
          let lines = [];
          let lengthLeft = blotLength;
          blot.children.forEachAt(blotIndex, blotLength, (child, childIndex, childLength) => {
            if (isLine(child)) {
              lines.push(child);
            } else if (child instanceof ContainerBlot$1) {
              lines = lines.concat(getLines(child, childIndex, lengthLeft));
            }
            lengthLeft -= childLength;
          });
          return lines;
        };
        return getLines(this, index, length);
      }
      optimize() {
        let mutations = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        let context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (this.batch) return;
        super.optimize(mutations, context);
        if (mutations.length > 0) {
          this.emitter.emit(emitter_default.events.SCROLL_OPTIMIZE, mutations, context);
        }
      }
      path(index) {
        return super.path(index).slice(1);
      }
      remove() {
      }
      update(mutations) {
        if (this.batch) {
          if (Array.isArray(mutations)) {
            this.batch = this.batch.concat(mutations);
          }
          return;
        }
        let source = emitter_default.sources.USER;
        if (typeof mutations === "string") {
          source = mutations;
        }
        if (!Array.isArray(mutations)) {
          mutations = this.observer.takeRecords();
        }
        mutations = mutations.filter((_ref2) => {
          let {
            target
          } = _ref2;
          const blot = this.find(target, true);
          return blot && !isUpdatable(blot);
        });
        if (mutations.length > 0) {
          this.emitter.emit(emitter_default.events.SCROLL_BEFORE_UPDATE, source, mutations);
        }
        super.update(mutations.concat([]));
        if (mutations.length > 0) {
          this.emitter.emit(emitter_default.events.SCROLL_UPDATE, source, mutations);
        }
      }
      updateEmbedAt(index, key, change) {
        const [blot] = this.descendant((b) => b instanceof BlockEmbed, index);
        if (blot && blot.statics.blotName === key && isUpdatable(blot)) {
          blot.updateContent(change);
        }
      }
      handleDragStart(event) {
        event.preventDefault();
      }
      deltaToRenderBlocks(delta) {
        const renderBlocks = [];
        let currentBlockDelta = new import_quill_delta.default();
        delta.forEach((op) => {
          const insert = op == null ? void 0 : op.insert;
          if (!insert) return;
          if (typeof insert === "string") {
            const splitted = insert.split("\n");
            splitted.slice(0, -1).forEach((text) => {
              currentBlockDelta.insert(text, op.attributes);
              renderBlocks.push({
                type: "block",
                delta: currentBlockDelta,
                attributes: op.attributes ?? {}
              });
              currentBlockDelta = new import_quill_delta.default();
            });
            const last = splitted[splitted.length - 1];
            if (last) {
              currentBlockDelta.insert(last, op.attributes);
            }
          } else {
            const key = Object.keys(insert)[0];
            if (!key) return;
            if (this.query(key, Scope.INLINE)) {
              currentBlockDelta.push(op);
            } else {
              if (currentBlockDelta.length()) {
                renderBlocks.push({
                  type: "block",
                  delta: currentBlockDelta,
                  attributes: {}
                });
              }
              currentBlockDelta = new import_quill_delta.default();
              renderBlocks.push({
                type: "blockEmbed",
                key,
                value: insert[key],
                attributes: op.attributes ?? {}
              });
            }
          }
        });
        if (currentBlockDelta.length()) {
          renderBlocks.push({
            type: "block",
            delta: currentBlockDelta,
            attributes: {}
          });
        }
        return renderBlocks;
      }
      createBlock(attributes, refBlot) {
        let blotName;
        const formats = {};
        Object.entries(attributes).forEach((_ref3) => {
          let [key, value] = _ref3;
          const isBlockBlot = this.query(key, Scope.BLOCK & Scope.BLOT) != null;
          if (isBlockBlot) {
            blotName = key;
          } else {
            formats[key] = value;
          }
        });
        const block = this.create(blotName || this.statics.defaultChild.blotName, blotName ? attributes[blotName] : void 0);
        this.insertBefore(block, refBlot || void 0);
        const length = block.length();
        Object.entries(formats).forEach((_ref4) => {
          let [key, value] = _ref4;
          block.formatAt(0, length, key, value);
        });
        return block;
      }
    };
    __publicField(Scroll, "blotName", "scroll");
    __publicField(Scroll, "className", "ql-editor");
    __publicField(Scroll, "tagName", "DIV");
    __publicField(Scroll, "defaultChild", Block);
    __publicField(Scroll, "allowedChildren", [Block, BlockEmbed, container_default]);
    scroll_default = Scroll;
  }
});

// node_modules/quill/formats/align.js
var config, AlignAttribute, AlignClass, AlignStyle;
var init_align = __esm({
  "node_modules/quill/formats/align.js"() {
    init_parchment();
    config = {
      scope: Scope.BLOCK,
      whitelist: ["right", "center", "justify"]
    };
    AlignAttribute = new Attributor("align", "align", config);
    AlignClass = new ClassAttributor$1("align", "ql-align", config);
    AlignStyle = new StyleAttributor$1("align", "text-align", config);
  }
});

// node_modules/quill/formats/color.js
var ColorAttributor, ColorClass, ColorStyle;
var init_color = __esm({
  "node_modules/quill/formats/color.js"() {
    init_parchment();
    ColorAttributor = class extends StyleAttributor$1 {
      value(domNode) {
        let value = super.value(domNode);
        if (!value.startsWith("rgb(")) return value;
        value = value.replace(/^[^\d]+/, "").replace(/[^\d]+$/, "");
        const hex = value.split(",").map((component) => `00${parseInt(component, 10).toString(16)}`.slice(-2)).join("");
        return `#${hex}`;
      }
    };
    ColorClass = new ClassAttributor$1("color", "ql-color", {
      scope: Scope.INLINE
    });
    ColorStyle = new ColorAttributor("color", "color", {
      scope: Scope.INLINE
    });
  }
});

// node_modules/quill/formats/background.js
var BackgroundClass, BackgroundStyle;
var init_background = __esm({
  "node_modules/quill/formats/background.js"() {
    init_parchment();
    init_color();
    BackgroundClass = new ClassAttributor$1("background", "ql-bg", {
      scope: Scope.INLINE
    });
    BackgroundStyle = new ColorAttributor("background", "background-color", {
      scope: Scope.INLINE
    });
  }
});

// node_modules/quill/formats/code.js
var CodeBlockContainer, CodeBlock, Code;
var init_code = __esm({
  "node_modules/quill/formats/code.js"() {
    init_block();
    init_break();
    init_cursor();
    init_inline();
    init_text();
    init_container();
    init_quill();
    CodeBlockContainer = class extends container_default {
      static create(value) {
        const domNode = super.create(value);
        domNode.setAttribute("spellcheck", "false");
        return domNode;
      }
      code(index, length) {
        return this.children.map((child) => child.length() <= 1 ? "" : child.domNode.innerText).join("\n").slice(index, index + length);
      }
      html(index, length) {
        return `<pre>
${escapeText(this.code(index, length))}
</pre>`;
      }
    };
    CodeBlock = class extends Block {
      static register() {
        Quill.register(CodeBlockContainer);
      }
    };
    __publicField(CodeBlock, "TAB", "  ");
    Code = class extends inline_default {
    };
    Code.blotName = "code";
    Code.tagName = "CODE";
    CodeBlock.blotName = "code-block";
    CodeBlock.className = "ql-code-block";
    CodeBlock.tagName = "DIV";
    CodeBlockContainer.blotName = "code-block-container";
    CodeBlockContainer.className = "ql-code-block-container";
    CodeBlockContainer.tagName = "DIV";
    CodeBlockContainer.allowedChildren = [CodeBlock];
    CodeBlock.allowedChildren = [Text, break_default, cursor_default];
    CodeBlock.requiredContainer = CodeBlockContainer;
  }
});

// node_modules/quill/formats/direction.js
var config2, DirectionAttribute, DirectionClass, DirectionStyle;
var init_direction = __esm({
  "node_modules/quill/formats/direction.js"() {
    init_parchment();
    config2 = {
      scope: Scope.BLOCK,
      whitelist: ["rtl"]
    };
    DirectionAttribute = new Attributor("direction", "dir", config2);
    DirectionClass = new ClassAttributor$1("direction", "ql-direction", config2);
    DirectionStyle = new StyleAttributor$1("direction", "direction", config2);
  }
});

// node_modules/quill/formats/font.js
var config3, FontClass, FontStyleAttributor, FontStyle;
var init_font = __esm({
  "node_modules/quill/formats/font.js"() {
    init_parchment();
    config3 = {
      scope: Scope.INLINE,
      whitelist: ["serif", "monospace"]
    };
    FontClass = new ClassAttributor$1("font", "ql-font", config3);
    FontStyleAttributor = class extends StyleAttributor$1 {
      value(node) {
        return super.value(node).replace(/["']/g, "");
      }
    };
    FontStyle = new FontStyleAttributor("font", "font-family", config3);
  }
});

// node_modules/quill/formats/size.js
var SizeClass, SizeStyle;
var init_size = __esm({
  "node_modules/quill/formats/size.js"() {
    init_parchment();
    SizeClass = new ClassAttributor$1("size", "ql-size", {
      scope: Scope.INLINE,
      whitelist: ["small", "large", "huge"]
    });
    SizeStyle = new StyleAttributor$1("size", "font-size", {
      scope: Scope.INLINE,
      whitelist: ["10px", "18px", "32px"]
    });
  }
});

// node_modules/quill/modules/keyboard.js
function makeCodeBlockHandler(indent) {
  return {
    key: "Tab",
    shiftKey: !indent,
    format: {
      "code-block": true
    },
    handler(range, _ref) {
      let {
        event
      } = _ref;
      const CodeBlock2 = this.quill.scroll.query("code-block");
      const {
        TAB
      } = CodeBlock2;
      if (range.length === 0 && !event.shiftKey) {
        this.quill.insertText(range.index, TAB, Quill.sources.USER);
        this.quill.setSelection(range.index + TAB.length, Quill.sources.SILENT);
        return;
      }
      const lines = range.length === 0 ? this.quill.getLines(range.index, 1) : this.quill.getLines(range);
      let {
        index,
        length
      } = range;
      lines.forEach((line, i) => {
        if (indent) {
          line.insertAt(0, TAB);
          if (i === 0) {
            index += TAB.length;
          } else {
            length += TAB.length;
          }
        } else if (line.domNode.textContent.startsWith(TAB)) {
          line.deleteAt(0, TAB.length);
          if (i === 0) {
            index -= TAB.length;
          } else {
            length -= TAB.length;
          }
        }
      });
      this.quill.update(Quill.sources.USER);
      this.quill.setSelection(index, length, Quill.sources.SILENT);
    }
  };
}
function makeEmbedArrowHandler(key, shiftKey) {
  const where = key === "ArrowLeft" ? "prefix" : "suffix";
  return {
    key,
    shiftKey,
    altKey: null,
    [where]: /^$/,
    handler(range) {
      let {
        index
      } = range;
      if (key === "ArrowRight") {
        index += range.length + 1;
      }
      const [leaf] = this.quill.getLeaf(index);
      if (!(leaf instanceof EmbedBlot$1)) return true;
      if (key === "ArrowLeft") {
        if (shiftKey) {
          this.quill.setSelection(range.index - 1, range.length + 1, Quill.sources.USER);
        } else {
          this.quill.setSelection(range.index - 1, Quill.sources.USER);
        }
      } else if (shiftKey) {
        this.quill.setSelection(range.index, range.length + 1, Quill.sources.USER);
      } else {
        this.quill.setSelection(range.index + range.length + 1, Quill.sources.USER);
      }
      return false;
    }
  };
}
function makeFormatHandler(format) {
  return {
    key: format[0],
    shortKey: true,
    handler(range, context) {
      this.quill.format(format, !context.format[format], Quill.sources.USER);
    }
  };
}
function makeTableArrowHandler(up) {
  return {
    key: up ? "ArrowUp" : "ArrowDown",
    collapsed: true,
    format: ["table"],
    handler(range, context) {
      const key = up ? "prev" : "next";
      const cell = context.line;
      const targetRow = cell.parent[key];
      if (targetRow != null) {
        if (targetRow.statics.blotName === "table-row") {
          let targetCell = targetRow.children.head;
          let cur = cell;
          while (cur.prev != null) {
            cur = cur.prev;
            targetCell = targetCell.next;
          }
          const index = targetCell.offset(this.quill.scroll) + Math.min(context.offset, targetCell.length() - 1);
          this.quill.setSelection(index, 0, Quill.sources.USER);
        }
      } else {
        const targetLine = cell.table()[key];
        if (targetLine != null) {
          if (up) {
            this.quill.setSelection(targetLine.offset(this.quill.scroll) + targetLine.length() - 1, 0, Quill.sources.USER);
          } else {
            this.quill.setSelection(targetLine.offset(this.quill.scroll), 0, Quill.sources.USER);
          }
        }
      }
      return false;
    }
  };
}
function normalize(binding) {
  if (typeof binding === "string" || typeof binding === "number") {
    binding = {
      key: binding
    };
  } else if (typeof binding === "object") {
    binding = cloneDeep_default(binding);
  } else {
    return null;
  }
  if (binding.shortKey) {
    binding[SHORTKEY] = binding.shortKey;
    delete binding.shortKey;
  }
  return binding;
}
function deleteRange(_ref2) {
  let {
    quill,
    range
  } = _ref2;
  const lines = quill.getLines(range);
  let formats = {};
  if (lines.length > 1) {
    const firstFormats = lines[0].formats();
    const lastFormats = lines[lines.length - 1].formats();
    formats = import_quill_delta2.AttributeMap.diff(lastFormats, firstFormats) || {};
  }
  quill.deleteText(range, Quill.sources.USER);
  if (Object.keys(formats).length > 0) {
    quill.formatLine(range.index, 1, formats, Quill.sources.USER);
  }
  quill.setSelection(range.index, Quill.sources.SILENT);
}
function tableSide(_table, row, cell, offset) {
  if (row.prev == null && row.next == null) {
    if (cell.prev == null && cell.next == null) {
      return offset === 0 ? -1 : 1;
    }
    return cell.prev == null ? -1 : 1;
  }
  if (row.prev == null) {
    return -1;
  }
  if (row.next == null) {
    return 1;
  }
  return null;
}
var import_quill_delta2, debug, SHORTKEY, Keyboard, defaultOptions;
var init_keyboard = __esm({
  "node_modules/quill/modules/keyboard.js"() {
    init_lodash();
    import_quill_delta2 = __toESM(require_Delta(), 1);
    init_parchment();
    init_quill();
    init_logger();
    init_module();
    debug = logger_default("quill:keyboard");
    SHORTKEY = /Mac/i.test(navigator.platform) ? "metaKey" : "ctrlKey";
    Keyboard = class _Keyboard extends module_default {
      static match(evt, binding) {
        if (["altKey", "ctrlKey", "metaKey", "shiftKey"].some((key) => {
          return !!binding[key] !== evt[key] && binding[key] !== null;
        })) {
          return false;
        }
        return binding.key === evt.key || binding.key === evt.which;
      }
      constructor(quill, options) {
        super(quill, options);
        this.bindings = {};
        Object.keys(this.options.bindings).forEach((name) => {
          if (this.options.bindings[name]) {
            this.addBinding(this.options.bindings[name]);
          }
        });
        this.addBinding({
          key: "Enter",
          shiftKey: null
        }, this.handleEnter);
        this.addBinding({
          key: "Enter",
          metaKey: null,
          ctrlKey: null,
          altKey: null
        }, () => {
        });
        if (/Firefox/i.test(navigator.userAgent)) {
          this.addBinding({
            key: "Backspace"
          }, {
            collapsed: true
          }, this.handleBackspace);
          this.addBinding({
            key: "Delete"
          }, {
            collapsed: true
          }, this.handleDelete);
        } else {
          this.addBinding({
            key: "Backspace"
          }, {
            collapsed: true,
            prefix: /^.?$/
          }, this.handleBackspace);
          this.addBinding({
            key: "Delete"
          }, {
            collapsed: true,
            suffix: /^.?$/
          }, this.handleDelete);
        }
        this.addBinding({
          key: "Backspace"
        }, {
          collapsed: false
        }, this.handleDeleteRange);
        this.addBinding({
          key: "Delete"
        }, {
          collapsed: false
        }, this.handleDeleteRange);
        this.addBinding({
          key: "Backspace",
          altKey: null,
          ctrlKey: null,
          metaKey: null,
          shiftKey: null
        }, {
          collapsed: true,
          offset: 0
        }, this.handleBackspace);
        this.listen();
      }
      addBinding(keyBinding) {
        let context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let handler = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        const binding = normalize(keyBinding);
        if (binding == null) {
          debug.warn("Attempted to add invalid keyboard binding", binding);
          return;
        }
        if (typeof context === "function") {
          context = {
            handler: context
          };
        }
        if (typeof handler === "function") {
          handler = {
            handler
          };
        }
        const keys = Array.isArray(binding.key) ? binding.key : [binding.key];
        keys.forEach((key) => {
          const singleBinding = {
            ...binding,
            key,
            ...context,
            ...handler
          };
          this.bindings[singleBinding.key] = this.bindings[singleBinding.key] || [];
          this.bindings[singleBinding.key].push(singleBinding);
        });
      }
      listen() {
        this.quill.root.addEventListener("keydown", (evt) => {
          if (evt.defaultPrevented || evt.isComposing) return;
          const isComposing = evt.keyCode === 229 && (evt.key === "Enter" || evt.key === "Backspace");
          if (isComposing) return;
          const bindings = (this.bindings[evt.key] || []).concat(this.bindings[evt.which] || []);
          const matches = bindings.filter((binding) => _Keyboard.match(evt, binding));
          if (matches.length === 0) return;
          const blot = Quill.find(evt.target, true);
          if (blot && blot.scroll !== this.quill.scroll) return;
          const range = this.quill.getSelection();
          if (range == null || !this.quill.hasFocus()) return;
          const [line, offset] = this.quill.getLine(range.index);
          const [leafStart, offsetStart] = this.quill.getLeaf(range.index);
          const [leafEnd, offsetEnd] = range.length === 0 ? [leafStart, offsetStart] : this.quill.getLeaf(range.index + range.length);
          const prefixText = leafStart instanceof TextBlot$1 ? leafStart.value().slice(0, offsetStart) : "";
          const suffixText = leafEnd instanceof TextBlot$1 ? leafEnd.value().slice(offsetEnd) : "";
          const curContext = {
            collapsed: range.length === 0,
            // @ts-expect-error Fix me later
            empty: range.length === 0 && line.length() <= 1,
            format: this.quill.getFormat(range),
            line,
            offset,
            prefix: prefixText,
            suffix: suffixText,
            event: evt
          };
          const prevented = matches.some((binding) => {
            if (binding.collapsed != null && binding.collapsed !== curContext.collapsed) {
              return false;
            }
            if (binding.empty != null && binding.empty !== curContext.empty) {
              return false;
            }
            if (binding.offset != null && binding.offset !== curContext.offset) {
              return false;
            }
            if (Array.isArray(binding.format)) {
              if (binding.format.every((name) => curContext.format[name] == null)) {
                return false;
              }
            } else if (typeof binding.format === "object") {
              if (!Object.keys(binding.format).every((name) => {
                if (binding.format[name] === true) return curContext.format[name] != null;
                if (binding.format[name] === false) return curContext.format[name] == null;
                return isEqual_default(binding.format[name], curContext.format[name]);
              })) {
                return false;
              }
            }
            if (binding.prefix != null && !binding.prefix.test(curContext.prefix)) {
              return false;
            }
            if (binding.suffix != null && !binding.suffix.test(curContext.suffix)) {
              return false;
            }
            return binding.handler.call(this, range, curContext, binding) !== true;
          });
          if (prevented) {
            evt.preventDefault();
          }
        });
      }
      handleBackspace(range, context) {
        const length = /[\uD800-\uDBFF][\uDC00-\uDFFF]$/.test(context.prefix) ? 2 : 1;
        if (range.index === 0 || this.quill.getLength() <= 1) return;
        let formats = {};
        const [line] = this.quill.getLine(range.index);
        let delta = new import_quill_delta2.default().retain(range.index - length).delete(length);
        if (context.offset === 0) {
          const [prev] = this.quill.getLine(range.index - 1);
          if (prev) {
            const isPrevLineEmpty = prev.statics.blotName === "block" && prev.length() <= 1;
            if (!isPrevLineEmpty) {
              const curFormats = line.formats();
              const prevFormats = this.quill.getFormat(range.index - 1, 1);
              formats = import_quill_delta2.AttributeMap.diff(curFormats, prevFormats) || {};
              if (Object.keys(formats).length > 0) {
                const formatDelta = new import_quill_delta2.default().retain(range.index + line.length() - 2).retain(1, formats);
                delta = delta.compose(formatDelta);
              }
            }
          }
        }
        this.quill.updateContents(delta, Quill.sources.USER);
        this.quill.focus();
      }
      handleDelete(range, context) {
        const length = /^[\uD800-\uDBFF][\uDC00-\uDFFF]/.test(context.suffix) ? 2 : 1;
        if (range.index >= this.quill.getLength() - length) return;
        let formats = {};
        const [line] = this.quill.getLine(range.index);
        let delta = new import_quill_delta2.default().retain(range.index).delete(length);
        if (context.offset >= line.length() - 1) {
          const [next] = this.quill.getLine(range.index + 1);
          if (next) {
            const curFormats = line.formats();
            const nextFormats = this.quill.getFormat(range.index, 1);
            formats = import_quill_delta2.AttributeMap.diff(curFormats, nextFormats) || {};
            if (Object.keys(formats).length > 0) {
              delta = delta.retain(next.length() - 1).retain(1, formats);
            }
          }
        }
        this.quill.updateContents(delta, Quill.sources.USER);
        this.quill.focus();
      }
      handleDeleteRange(range) {
        deleteRange({
          range,
          quill: this.quill
        });
        this.quill.focus();
      }
      handleEnter(range, context) {
        const lineFormats = Object.keys(context.format).reduce((formats, format) => {
          if (this.quill.scroll.query(format, Scope.BLOCK) && !Array.isArray(context.format[format])) {
            formats[format] = context.format[format];
          }
          return formats;
        }, {});
        const delta = new import_quill_delta2.default().retain(range.index).delete(range.length).insert("\n", lineFormats);
        this.quill.updateContents(delta, Quill.sources.USER);
        this.quill.setSelection(range.index + 1, Quill.sources.SILENT);
        this.quill.focus();
      }
    };
    defaultOptions = {
      bindings: {
        bold: makeFormatHandler("bold"),
        italic: makeFormatHandler("italic"),
        underline: makeFormatHandler("underline"),
        indent: {
          // highlight tab or tab at beginning of list, indent or blockquote
          key: "Tab",
          format: ["blockquote", "indent", "list"],
          handler(range, context) {
            if (context.collapsed && context.offset !== 0) return true;
            this.quill.format("indent", "+1", Quill.sources.USER);
            return false;
          }
        },
        outdent: {
          key: "Tab",
          shiftKey: true,
          format: ["blockquote", "indent", "list"],
          // highlight tab or tab at beginning of list, indent or blockquote
          handler(range, context) {
            if (context.collapsed && context.offset !== 0) return true;
            this.quill.format("indent", "-1", Quill.sources.USER);
            return false;
          }
        },
        "outdent backspace": {
          key: "Backspace",
          collapsed: true,
          shiftKey: null,
          metaKey: null,
          ctrlKey: null,
          altKey: null,
          format: ["indent", "list"],
          offset: 0,
          handler(range, context) {
            if (context.format.indent != null) {
              this.quill.format("indent", "-1", Quill.sources.USER);
            } else if (context.format.list != null) {
              this.quill.format("list", false, Quill.sources.USER);
            }
          }
        },
        "indent code-block": makeCodeBlockHandler(true),
        "outdent code-block": makeCodeBlockHandler(false),
        "remove tab": {
          key: "Tab",
          shiftKey: true,
          collapsed: true,
          prefix: /\t$/,
          handler(range) {
            this.quill.deleteText(range.index - 1, 1, Quill.sources.USER);
          }
        },
        tab: {
          key: "Tab",
          handler(range, context) {
            if (context.format.table) return true;
            this.quill.history.cutoff();
            const delta = new import_quill_delta2.default().retain(range.index).delete(range.length).insert("	");
            this.quill.updateContents(delta, Quill.sources.USER);
            this.quill.history.cutoff();
            this.quill.setSelection(range.index + 1, Quill.sources.SILENT);
            return false;
          }
        },
        "blockquote empty enter": {
          key: "Enter",
          collapsed: true,
          format: ["blockquote"],
          empty: true,
          handler() {
            this.quill.format("blockquote", false, Quill.sources.USER);
          }
        },
        "list empty enter": {
          key: "Enter",
          collapsed: true,
          format: ["list"],
          empty: true,
          handler(range, context) {
            const formats = {
              list: false
            };
            if (context.format.indent) {
              formats.indent = false;
            }
            this.quill.formatLine(range.index, range.length, formats, Quill.sources.USER);
          }
        },
        "checklist enter": {
          key: "Enter",
          collapsed: true,
          format: {
            list: "checked"
          },
          handler(range) {
            const [line, offset] = this.quill.getLine(range.index);
            const formats = {
              // @ts-expect-error Fix me later
              ...line.formats(),
              list: "checked"
            };
            const delta = new import_quill_delta2.default().retain(range.index).insert("\n", formats).retain(line.length() - offset - 1).retain(1, {
              list: "unchecked"
            });
            this.quill.updateContents(delta, Quill.sources.USER);
            this.quill.setSelection(range.index + 1, Quill.sources.SILENT);
            this.quill.scrollSelectionIntoView();
          }
        },
        "header enter": {
          key: "Enter",
          collapsed: true,
          format: ["header"],
          suffix: /^$/,
          handler(range, context) {
            const [line, offset] = this.quill.getLine(range.index);
            const delta = new import_quill_delta2.default().retain(range.index).insert("\n", context.format).retain(line.length() - offset - 1).retain(1, {
              header: null
            });
            this.quill.updateContents(delta, Quill.sources.USER);
            this.quill.setSelection(range.index + 1, Quill.sources.SILENT);
            this.quill.scrollSelectionIntoView();
          }
        },
        "table backspace": {
          key: "Backspace",
          format: ["table"],
          collapsed: true,
          offset: 0,
          handler() {
          }
        },
        "table delete": {
          key: "Delete",
          format: ["table"],
          collapsed: true,
          suffix: /^$/,
          handler() {
          }
        },
        "table enter": {
          key: "Enter",
          shiftKey: null,
          format: ["table"],
          handler(range) {
            const module = this.quill.getModule("table");
            if (module) {
              const [table, row, cell, offset] = module.getTable(range);
              const shift = tableSide(table, row, cell, offset);
              if (shift == null) return;
              let index = table.offset();
              if (shift < 0) {
                const delta = new import_quill_delta2.default().retain(index).insert("\n");
                this.quill.updateContents(delta, Quill.sources.USER);
                this.quill.setSelection(range.index + 1, range.length, Quill.sources.SILENT);
              } else if (shift > 0) {
                index += table.length();
                const delta = new import_quill_delta2.default().retain(index).insert("\n");
                this.quill.updateContents(delta, Quill.sources.USER);
                this.quill.setSelection(index, Quill.sources.USER);
              }
            }
          }
        },
        "table tab": {
          key: "Tab",
          shiftKey: null,
          format: ["table"],
          handler(range, context) {
            const {
              event,
              line: cell
            } = context;
            const offset = cell.offset(this.quill.scroll);
            if (event.shiftKey) {
              this.quill.setSelection(offset - 1, Quill.sources.USER);
            } else {
              this.quill.setSelection(offset + cell.length(), Quill.sources.USER);
            }
          }
        },
        "list autofill": {
          key: " ",
          shiftKey: null,
          collapsed: true,
          format: {
            "code-block": false,
            blockquote: false,
            table: false
          },
          prefix: /^\s*?(\d+\.|-|\*|\[ ?\]|\[x\])$/,
          handler(range, context) {
            if (this.quill.scroll.query("list") == null) return true;
            const {
              length
            } = context.prefix;
            const [line, offset] = this.quill.getLine(range.index);
            if (offset > length) return true;
            let value;
            switch (context.prefix.trim()) {
              case "[]":
              case "[ ]":
                value = "unchecked";
                break;
              case "[x]":
                value = "checked";
                break;
              case "-":
              case "*":
                value = "bullet";
                break;
              default:
                value = "ordered";
            }
            this.quill.insertText(range.index, " ", Quill.sources.USER);
            this.quill.history.cutoff();
            const delta = new import_quill_delta2.default().retain(range.index - offset).delete(length + 1).retain(line.length() - 2 - offset).retain(1, {
              list: value
            });
            this.quill.updateContents(delta, Quill.sources.USER);
            this.quill.history.cutoff();
            this.quill.setSelection(range.index - length, Quill.sources.SILENT);
            return false;
          }
        },
        "code exit": {
          key: "Enter",
          collapsed: true,
          format: ["code-block"],
          prefix: /^$/,
          suffix: /^\s*$/,
          handler(range) {
            const [line, offset] = this.quill.getLine(range.index);
            let numLines = 2;
            let cur = line;
            while (cur != null && cur.length() <= 1 && cur.formats()["code-block"]) {
              cur = cur.prev;
              numLines -= 1;
              if (numLines <= 0) {
                const delta = new import_quill_delta2.default().retain(range.index + line.length() - offset - 2).retain(1, {
                  "code-block": null
                }).delete(1);
                this.quill.updateContents(delta, Quill.sources.USER);
                this.quill.setSelection(range.index - 1, Quill.sources.SILENT);
                return false;
              }
            }
            return true;
          }
        },
        "embed left": makeEmbedArrowHandler("ArrowLeft", false),
        "embed left shift": makeEmbedArrowHandler("ArrowLeft", true),
        "embed right": makeEmbedArrowHandler("ArrowRight", false),
        "embed right shift": makeEmbedArrowHandler("ArrowRight", true),
        "table down": makeTableArrowHandler(false),
        "table up": makeTableArrowHandler(true)
      }
    };
    Keyboard.DEFAULTS = defaultOptions;
  }
});

// node_modules/quill/modules/normalizeExternalHTML/normalizers/googleDocs.js
function normalize2(doc) {
  if (doc.querySelector('[id^="docs-internal-guid-"]')) {
    normalizeFontWeight(doc);
    normalizeEmptyLines(doc);
  }
}
var normalWeightRegexp, blockTagNames, isBlockElement, normalizeEmptyLines, normalizeFontWeight;
var init_googleDocs = __esm({
  "node_modules/quill/modules/normalizeExternalHTML/normalizers/googleDocs.js"() {
    normalWeightRegexp = /font-weight:\s*normal/;
    blockTagNames = ["P", "OL", "UL"];
    isBlockElement = (element) => {
      return element && blockTagNames.includes(element.tagName);
    };
    normalizeEmptyLines = (doc) => {
      Array.from(doc.querySelectorAll("br")).filter((br) => isBlockElement(br.previousElementSibling) && isBlockElement(br.nextElementSibling)).forEach((br) => {
        var _a;
        (_a = br.parentNode) == null ? void 0 : _a.removeChild(br);
      });
    };
    normalizeFontWeight = (doc) => {
      Array.from(doc.querySelectorAll('b[style*="font-weight"]')).filter((node) => {
        var _a;
        return (_a = node.getAttribute("style")) == null ? void 0 : _a.match(normalWeightRegexp);
      }).forEach((node) => {
        var _a;
        const fragment = doc.createDocumentFragment();
        fragment.append(...node.childNodes);
        (_a = node.parentNode) == null ? void 0 : _a.replaceChild(fragment, node);
      });
    };
  }
});

// node_modules/quill/modules/normalizeExternalHTML/normalizers/msWord.js
function normalize3(doc) {
  if (doc.documentElement.getAttribute("xmlns:w") === "urn:schemas-microsoft-com:office:word") {
    normalizeListItem(doc);
  }
}
var ignoreRegexp, idRegexp, indentRegexp, parseListItem, normalizeListItem;
var init_msWord = __esm({
  "node_modules/quill/modules/normalizeExternalHTML/normalizers/msWord.js"() {
    ignoreRegexp = /\bmso-list:[^;]*ignore/i;
    idRegexp = /\bmso-list:[^;]*\bl(\d+)/i;
    indentRegexp = /\bmso-list:[^;]*\blevel(\d+)/i;
    parseListItem = (element, html) => {
      const style = element.getAttribute("style");
      const idMatch = style == null ? void 0 : style.match(idRegexp);
      if (!idMatch) {
        return null;
      }
      const id = Number(idMatch[1]);
      const indentMatch = style == null ? void 0 : style.match(indentRegexp);
      const indent = indentMatch ? Number(indentMatch[1]) : 1;
      const typeRegexp = new RegExp(`@list l${id}:level${indent}\\s*\\{[^\\}]*mso-level-number-format:\\s*([\\w-]+)`, "i");
      const typeMatch = html.match(typeRegexp);
      const type = typeMatch && typeMatch[1] === "bullet" ? "bullet" : "ordered";
      return {
        id,
        indent,
        type,
        element
      };
    };
    normalizeListItem = (doc) => {
      var _a, _b;
      const msoList = Array.from(doc.querySelectorAll("[style*=mso-list]"));
      const ignored = [];
      const others = [];
      msoList.forEach((node) => {
        const shouldIgnore = (node.getAttribute("style") || "").match(ignoreRegexp);
        if (shouldIgnore) {
          ignored.push(node);
        } else {
          others.push(node);
        }
      });
      ignored.forEach((node) => {
        var _a2;
        return (_a2 = node.parentNode) == null ? void 0 : _a2.removeChild(node);
      });
      const html = doc.documentElement.innerHTML;
      const listItems = others.map((element) => parseListItem(element, html)).filter((parsed) => parsed);
      while (listItems.length) {
        const childListItems = [];
        let current = listItems.shift();
        while (current) {
          childListItems.push(current);
          current = listItems.length && ((_a = listItems[0]) == null ? void 0 : _a.element) === current.element.nextElementSibling && // Different id means the next item doesn't belong to this group.
          listItems[0].id === current.id ? listItems.shift() : null;
        }
        const ul = document.createElement("ul");
        childListItems.forEach((listItem) => {
          const li = document.createElement("li");
          li.setAttribute("data-list", listItem.type);
          if (listItem.indent > 1) {
            li.setAttribute("class", `ql-indent-${listItem.indent - 1}`);
          }
          li.innerHTML = listItem.element.innerHTML;
          ul.appendChild(li);
        });
        const element = (_b = childListItems[0]) == null ? void 0 : _b.element;
        const {
          parentNode
        } = element ?? {};
        if (element) {
          parentNode == null ? void 0 : parentNode.replaceChild(ul, element);
        }
        childListItems.slice(1).forEach((_ref) => {
          let {
            element: e
          } = _ref;
          parentNode == null ? void 0 : parentNode.removeChild(e);
        });
      }
    };
  }
});

// node_modules/quill/modules/normalizeExternalHTML/index.js
var NORMALIZERS, normalizeExternalHTML, normalizeExternalHTML_default;
var init_normalizeExternalHTML = __esm({
  "node_modules/quill/modules/normalizeExternalHTML/index.js"() {
    init_googleDocs();
    init_msWord();
    NORMALIZERS = [normalize3, normalize2];
    normalizeExternalHTML = (doc) => {
      if (doc.documentElement) {
        NORMALIZERS.forEach((normalize4) => {
          normalize4(doc);
        });
      }
    };
    normalizeExternalHTML_default = normalizeExternalHTML;
  }
});

// node_modules/quill/modules/clipboard.js
function applyFormat(delta, format, value, scroll) {
  if (!scroll.query(format)) {
    return delta;
  }
  return delta.reduce((newDelta, op) => {
    if (!op.insert) return newDelta;
    if (op.attributes && op.attributes[format]) {
      return newDelta.push(op);
    }
    const formats = value ? {
      [format]: value
    } : {};
    return newDelta.insert(op.insert, {
      ...formats,
      ...op.attributes
    });
  }, new import_quill_delta3.default());
}
function deltaEndsWith(delta, text) {
  let endText = "";
  for (let i = delta.ops.length - 1; i >= 0 && endText.length < text.length; --i) {
    const op = delta.ops[i];
    if (typeof op.insert !== "string") break;
    endText = op.insert + endText;
  }
  return endText.slice(-1 * text.length) === text;
}
function isLine2(node, scroll) {
  if (!(node instanceof Element)) return false;
  const match = scroll.query(node);
  if (match && match.prototype instanceof EmbedBlot$1) return false;
  return ["address", "article", "blockquote", "canvas", "dd", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "iframe", "li", "main", "nav", "ol", "output", "p", "pre", "section", "table", "td", "tr", "ul", "video"].includes(node.tagName.toLowerCase());
}
function isBetweenInlineElements(node, scroll) {
  return node.previousElementSibling && node.nextElementSibling && !isLine2(node.previousElementSibling, scroll) && !isLine2(node.nextElementSibling, scroll);
}
function isPre(node) {
  if (node == null) return false;
  if (!preNodes.has(node)) {
    if (node.tagName === "PRE") {
      preNodes.set(node, true);
    } else {
      preNodes.set(node, isPre(node.parentNode));
    }
  }
  return preNodes.get(node);
}
function traverse(scroll, node, elementMatchers, textMatchers, nodeMatches) {
  if (node.nodeType === node.TEXT_NODE) {
    return textMatchers.reduce((delta, matcher) => {
      return matcher(node, delta, scroll);
    }, new import_quill_delta3.default());
  }
  if (node.nodeType === node.ELEMENT_NODE) {
    return Array.from(node.childNodes || []).reduce((delta, childNode) => {
      let childrenDelta = traverse(scroll, childNode, elementMatchers, textMatchers, nodeMatches);
      if (childNode.nodeType === node.ELEMENT_NODE) {
        childrenDelta = elementMatchers.reduce((reducedDelta, matcher) => {
          return matcher(childNode, reducedDelta, scroll);
        }, childrenDelta);
        childrenDelta = (nodeMatches.get(childNode) || []).reduce((reducedDelta, matcher) => {
          return matcher(childNode, reducedDelta, scroll);
        }, childrenDelta);
      }
      return delta.concat(childrenDelta);
    }, new import_quill_delta3.default());
  }
  return new import_quill_delta3.default();
}
function createMatchAlias(format) {
  return (_node, delta, scroll) => {
    return applyFormat(delta, format, true, scroll);
  };
}
function matchAttributor(node, delta, scroll) {
  const attributes = Attributor.keys(node);
  const classes = ClassAttributor$1.keys(node);
  const styles = StyleAttributor$1.keys(node);
  const formats = {};
  attributes.concat(classes).concat(styles).forEach((name) => {
    let attr = scroll.query(name, Scope.ATTRIBUTE);
    if (attr != null) {
      formats[attr.attrName] = attr.value(node);
      if (formats[attr.attrName]) return;
    }
    attr = ATTRIBUTE_ATTRIBUTORS[name];
    if (attr != null && (attr.attrName === name || attr.keyName === name)) {
      formats[attr.attrName] = attr.value(node) || void 0;
    }
    attr = STYLE_ATTRIBUTORS[name];
    if (attr != null && (attr.attrName === name || attr.keyName === name)) {
      attr = STYLE_ATTRIBUTORS[name];
      formats[attr.attrName] = attr.value(node) || void 0;
    }
  });
  return Object.entries(formats).reduce((newDelta, _ref4) => {
    let [name, value] = _ref4;
    return applyFormat(newDelta, name, value, scroll);
  }, delta);
}
function matchBlot(node, delta, scroll) {
  const match = scroll.query(node);
  if (match == null) return delta;
  if (match.prototype instanceof EmbedBlot$1) {
    const embed = {};
    const value = match.value(node);
    if (value != null) {
      embed[match.blotName] = value;
      return new import_quill_delta3.default().insert(embed, match.formats(node, scroll));
    }
  } else {
    if (match.prototype instanceof BlockBlot$1 && !deltaEndsWith(delta, "\n")) {
      delta.insert("\n");
    }
    if ("blotName" in match && "formats" in match && typeof match.formats === "function") {
      return applyFormat(delta, match.blotName, match.formats(node, scroll), scroll);
    }
  }
  return delta;
}
function matchBreak(node, delta) {
  if (!deltaEndsWith(delta, "\n")) {
    delta.insert("\n");
  }
  return delta;
}
function matchCodeBlock(node, delta, scroll) {
  const match = scroll.query("code-block");
  const language = match && "formats" in match && typeof match.formats === "function" ? match.formats(node, scroll) : true;
  return applyFormat(delta, "code-block", language, scroll);
}
function matchIgnore() {
  return new import_quill_delta3.default();
}
function matchIndent(node, delta, scroll) {
  const match = scroll.query(node);
  if (match == null || // @ts-expect-error
  match.blotName !== "list" || !deltaEndsWith(delta, "\n")) {
    return delta;
  }
  let indent = -1;
  let parent = node.parentNode;
  while (parent != null) {
    if (["OL", "UL"].includes(parent.tagName)) {
      indent += 1;
    }
    parent = parent.parentNode;
  }
  if (indent <= 0) return delta;
  return delta.reduce((composed, op) => {
    if (!op.insert) return composed;
    if (op.attributes && typeof op.attributes.indent === "number") {
      return composed.push(op);
    }
    return composed.insert(op.insert, {
      indent,
      ...op.attributes || {}
    });
  }, new import_quill_delta3.default());
}
function matchList(node, delta, scroll) {
  const element = node;
  let list = element.tagName === "OL" ? "ordered" : "bullet";
  const checkedAttr = element.getAttribute("data-checked");
  if (checkedAttr) {
    list = checkedAttr === "true" ? "checked" : "unchecked";
  }
  return applyFormat(delta, "list", list, scroll);
}
function matchNewline(node, delta, scroll) {
  if (!deltaEndsWith(delta, "\n")) {
    if (isLine2(node, scroll) && (node.childNodes.length > 0 || node instanceof HTMLParagraphElement)) {
      return delta.insert("\n");
    }
    if (delta.length() > 0 && node.nextSibling) {
      let nextSibling = node.nextSibling;
      while (nextSibling != null) {
        if (isLine2(nextSibling, scroll)) {
          return delta.insert("\n");
        }
        const match = scroll.query(nextSibling);
        if (match && match.prototype instanceof BlockEmbed) {
          return delta.insert("\n");
        }
        nextSibling = nextSibling.firstChild;
      }
    }
  }
  return delta;
}
function matchStyles(node, delta, scroll) {
  var _a;
  const formats = {};
  const style = node.style || {};
  if (style.fontStyle === "italic") {
    formats.italic = true;
  }
  if (style.textDecoration === "underline") {
    formats.underline = true;
  }
  if (style.textDecoration === "line-through") {
    formats.strike = true;
  }
  if (((_a = style.fontWeight) == null ? void 0 : _a.startsWith("bold")) || // @ts-expect-error Fix me later
  parseInt(style.fontWeight, 10) >= 700) {
    formats.bold = true;
  }
  delta = Object.entries(formats).reduce((newDelta, _ref5) => {
    let [name, value] = _ref5;
    return applyFormat(newDelta, name, value, scroll);
  }, delta);
  if (parseFloat(style.textIndent || 0) > 0) {
    return new import_quill_delta3.default().insert("	").concat(delta);
  }
  return delta;
}
function matchTable(node, delta, scroll) {
  var _a, _b;
  const table = ((_a = node.parentElement) == null ? void 0 : _a.tagName) === "TABLE" ? node.parentElement : (_b = node.parentElement) == null ? void 0 : _b.parentElement;
  if (table != null) {
    const rows = Array.from(table.querySelectorAll("tr"));
    const row = rows.indexOf(node) + 1;
    return applyFormat(delta, "table", row, scroll);
  }
  return delta;
}
function matchText(node, delta, scroll) {
  var _a;
  let text = node.data;
  if (((_a = node.parentElement) == null ? void 0 : _a.tagName) === "O:P") {
    return delta.insert(text.trim());
  }
  if (!isPre(node)) {
    if (text.trim().length === 0 && text.includes("\n") && !isBetweenInlineElements(node, scroll)) {
      return delta;
    }
    text = text.replace(/[^\S\u00a0]/g, " ");
    text = text.replace(/ {2,}/g, " ");
    if (node.previousSibling == null && node.parentElement != null && isLine2(node.parentElement, scroll) || node.previousSibling instanceof Element && isLine2(node.previousSibling, scroll)) {
      text = text.replace(/^ /, "");
    }
    if (node.nextSibling == null && node.parentElement != null && isLine2(node.parentElement, scroll) || node.nextSibling instanceof Element && isLine2(node.nextSibling, scroll)) {
      text = text.replace(/ $/, "");
    }
    text = text.replaceAll("", " ");
  }
  return delta.insert(text);
}
var import_quill_delta3, debug2, CLIPBOARD_CONFIG, ATTRIBUTE_ATTRIBUTORS, STYLE_ATTRIBUTORS, Clipboard, preNodes;
var init_clipboard = __esm({
  "node_modules/quill/modules/clipboard.js"() {
    init_parchment();
    import_quill_delta3 = __toESM(require_Delta(), 1);
    init_block();
    init_logger();
    init_module();
    init_quill();
    init_align();
    init_background();
    init_code();
    init_color();
    init_direction();
    init_font();
    init_size();
    init_keyboard();
    init_normalizeExternalHTML();
    debug2 = logger_default("quill:clipboard");
    CLIPBOARD_CONFIG = [[Node.TEXT_NODE, matchText], [Node.TEXT_NODE, matchNewline], ["br", matchBreak], [Node.ELEMENT_NODE, matchNewline], [Node.ELEMENT_NODE, matchBlot], [Node.ELEMENT_NODE, matchAttributor], [Node.ELEMENT_NODE, matchStyles], ["li", matchIndent], ["ol, ul", matchList], ["pre", matchCodeBlock], ["tr", matchTable], ["b", createMatchAlias("bold")], ["i", createMatchAlias("italic")], ["strike", createMatchAlias("strike")], ["style", matchIgnore]];
    ATTRIBUTE_ATTRIBUTORS = [AlignAttribute, DirectionAttribute].reduce((memo, attr) => {
      memo[attr.keyName] = attr;
      return memo;
    }, {});
    STYLE_ATTRIBUTORS = [AlignStyle, BackgroundStyle, ColorStyle, DirectionStyle, FontStyle, SizeStyle].reduce((memo, attr) => {
      memo[attr.keyName] = attr;
      return memo;
    }, {});
    Clipboard = class extends module_default {
      constructor(quill, options) {
        super(quill, options);
        this.quill.root.addEventListener("copy", (e) => this.onCaptureCopy(e, false));
        this.quill.root.addEventListener("cut", (e) => this.onCaptureCopy(e, true));
        this.quill.root.addEventListener("paste", this.onCapturePaste.bind(this));
        this.matchers = [];
        CLIPBOARD_CONFIG.concat(this.options.matchers ?? []).forEach((_ref) => {
          let [selector, matcher] = _ref;
          this.addMatcher(selector, matcher);
        });
      }
      addMatcher(selector, matcher) {
        this.matchers.push([selector, matcher]);
      }
      convert(_ref2) {
        let {
          html,
          text
        } = _ref2;
        let formats = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (formats[CodeBlock.blotName]) {
          return new import_quill_delta3.default().insert(text || "", {
            [CodeBlock.blotName]: formats[CodeBlock.blotName]
          });
        }
        if (!html) {
          return new import_quill_delta3.default().insert(text || "", formats);
        }
        const delta = this.convertHTML(html);
        if (deltaEndsWith(delta, "\n") && (delta.ops[delta.ops.length - 1].attributes == null || formats.table)) {
          return delta.compose(new import_quill_delta3.default().retain(delta.length() - 1).delete(1));
        }
        return delta;
      }
      normalizeHTML(doc) {
        normalizeExternalHTML_default(doc);
      }
      convertHTML(html) {
        const doc = new DOMParser().parseFromString(html, "text/html");
        this.normalizeHTML(doc);
        const container = doc.body;
        const nodeMatches = /* @__PURE__ */ new WeakMap();
        const [elementMatchers, textMatchers] = this.prepareMatching(container, nodeMatches);
        return traverse(this.quill.scroll, container, elementMatchers, textMatchers, nodeMatches);
      }
      dangerouslyPasteHTML(index, html) {
        let source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Quill.sources.API;
        if (typeof index === "string") {
          const delta = this.convert({
            html: index,
            text: ""
          });
          this.quill.setContents(delta, html);
          this.quill.setSelection(0, Quill.sources.SILENT);
        } else {
          const paste = this.convert({
            html,
            text: ""
          });
          this.quill.updateContents(new import_quill_delta3.default().retain(index).concat(paste), source);
          this.quill.setSelection(index + paste.length(), Quill.sources.SILENT);
        }
      }
      onCaptureCopy(e) {
        var _a, _b;
        let isCut = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        if (e.defaultPrevented) return;
        e.preventDefault();
        const [range] = this.quill.selection.getRange();
        if (range == null) return;
        const {
          html,
          text
        } = this.onCopy(range, isCut);
        (_a = e.clipboardData) == null ? void 0 : _a.setData("text/plain", text);
        (_b = e.clipboardData) == null ? void 0 : _b.setData("text/html", html);
        if (isCut) {
          deleteRange({
            range,
            quill: this.quill
          });
        }
      }
      /*
       * https://www.iana.org/assignments/media-types/text/uri-list
       */
      normalizeURIList(urlList) {
        return urlList.split(/\r?\n/).filter((url) => url[0] !== "#").join("\n");
      }
      onCapturePaste(e) {
        var _a, _b, _c, _d, _e;
        if (e.defaultPrevented || !this.quill.isEnabled()) return;
        e.preventDefault();
        const range = this.quill.getSelection(true);
        if (range == null) return;
        const html = (_a = e.clipboardData) == null ? void 0 : _a.getData("text/html");
        let text = (_b = e.clipboardData) == null ? void 0 : _b.getData("text/plain");
        if (!html && !text) {
          const urlList = (_c = e.clipboardData) == null ? void 0 : _c.getData("text/uri-list");
          if (urlList) {
            text = this.normalizeURIList(urlList);
          }
        }
        const files = Array.from(((_d = e.clipboardData) == null ? void 0 : _d.files) || []);
        if (!html && files.length > 0) {
          this.quill.uploader.upload(range, files);
          return;
        }
        if (html && files.length > 0) {
          const doc = new DOMParser().parseFromString(html, "text/html");
          if (doc.body.childElementCount === 1 && ((_e = doc.body.firstElementChild) == null ? void 0 : _e.tagName) === "IMG") {
            this.quill.uploader.upload(range, files);
            return;
          }
        }
        this.onPaste(range, {
          html,
          text
        });
      }
      onCopy(range) {
        const text = this.quill.getText(range);
        const html = this.quill.getSemanticHTML(range);
        return {
          html,
          text
        };
      }
      onPaste(range, _ref3) {
        let {
          text,
          html
        } = _ref3;
        const formats = this.quill.getFormat(range.index);
        const pastedDelta = this.convert({
          text,
          html
        }, formats);
        debug2.log("onPaste", pastedDelta, {
          text,
          html
        });
        const delta = new import_quill_delta3.default().retain(range.index).delete(range.length).concat(pastedDelta);
        this.quill.updateContents(delta, Quill.sources.USER);
        this.quill.setSelection(delta.length() - range.length, Quill.sources.SILENT);
        this.quill.scrollSelectionIntoView();
      }
      prepareMatching(container, nodeMatches) {
        const elementMatchers = [];
        const textMatchers = [];
        this.matchers.forEach((pair) => {
          const [selector, matcher] = pair;
          switch (selector) {
            case Node.TEXT_NODE:
              textMatchers.push(matcher);
              break;
            case Node.ELEMENT_NODE:
              elementMatchers.push(matcher);
              break;
            default:
              Array.from(container.querySelectorAll(selector)).forEach((node) => {
                if (nodeMatches.has(node)) {
                  const matches = nodeMatches.get(node);
                  matches == null ? void 0 : matches.push(matcher);
                } else {
                  nodeMatches.set(node, [matcher]);
                }
              });
              break;
          }
        });
        return [elementMatchers, textMatchers];
      }
    };
    __publicField(Clipboard, "DEFAULTS", {
      matchers: []
    });
    preNodes = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/quill/modules/history.js
function transformStack(stack, delta) {
  let remoteDelta = delta;
  for (let i = stack.length - 1; i >= 0; i -= 1) {
    const oldItem = stack[i];
    stack[i] = {
      delta: remoteDelta.transform(oldItem.delta, true),
      range: oldItem.range && transformRange(oldItem.range, remoteDelta)
    };
    remoteDelta = oldItem.delta.transform(remoteDelta);
    if (stack[i].delta.length() === 0) {
      stack.splice(i, 1);
    }
  }
}
function endsWithNewlineChange(scroll, delta) {
  const lastOp = delta.ops[delta.ops.length - 1];
  if (lastOp == null) return false;
  if (lastOp.insert != null) {
    return typeof lastOp.insert === "string" && lastOp.insert.endsWith("\n");
  }
  if (lastOp.attributes != null) {
    return Object.keys(lastOp.attributes).some((attr) => {
      return scroll.query(attr, Scope.BLOCK) != null;
    });
  }
  return false;
}
function getLastChangeIndex(scroll, delta) {
  const deleteLength = delta.reduce((length, op) => {
    return length + (op.delete || 0);
  }, 0);
  let changeIndex = delta.length() - deleteLength;
  if (endsWithNewlineChange(scroll, delta)) {
    changeIndex -= 1;
  }
  return changeIndex;
}
function transformRange(range, delta) {
  if (!range) return range;
  const start = delta.transformPosition(range.index);
  const end = delta.transformPosition(range.index + range.length);
  return {
    index: start,
    length: end - start
  };
}
var History;
var init_history = __esm({
  "node_modules/quill/modules/history.js"() {
    init_parchment();
    init_module();
    init_quill();
    History = class extends module_default {
      constructor(quill, options) {
        super(quill, options);
        __publicField(this, "lastRecorded", 0);
        __publicField(this, "ignoreChange", false);
        __publicField(this, "stack", {
          undo: [],
          redo: []
        });
        __publicField(this, "currentRange", null);
        this.quill.on(Quill.events.EDITOR_CHANGE, (eventName, value, oldValue, source) => {
          if (eventName === Quill.events.SELECTION_CHANGE) {
            if (value && source !== Quill.sources.SILENT) {
              this.currentRange = value;
            }
          } else if (eventName === Quill.events.TEXT_CHANGE) {
            if (!this.ignoreChange) {
              if (!this.options.userOnly || source === Quill.sources.USER) {
                this.record(value, oldValue);
              } else {
                this.transform(value);
              }
            }
            this.currentRange = transformRange(this.currentRange, value);
          }
        });
        this.quill.keyboard.addBinding({
          key: "z",
          shortKey: true
        }, this.undo.bind(this));
        this.quill.keyboard.addBinding({
          key: ["z", "Z"],
          shortKey: true,
          shiftKey: true
        }, this.redo.bind(this));
        if (/Win/i.test(navigator.platform)) {
          this.quill.keyboard.addBinding({
            key: "y",
            shortKey: true
          }, this.redo.bind(this));
        }
        this.quill.root.addEventListener("beforeinput", (event) => {
          if (event.inputType === "historyUndo") {
            this.undo();
            event.preventDefault();
          } else if (event.inputType === "historyRedo") {
            this.redo();
            event.preventDefault();
          }
        });
      }
      change(source, dest) {
        if (this.stack[source].length === 0) return;
        const item = this.stack[source].pop();
        if (!item) return;
        const base = this.quill.getContents();
        const inverseDelta = item.delta.invert(base);
        this.stack[dest].push({
          delta: inverseDelta,
          range: transformRange(item.range, inverseDelta)
        });
        this.lastRecorded = 0;
        this.ignoreChange = true;
        this.quill.updateContents(item.delta, Quill.sources.USER);
        this.ignoreChange = false;
        this.restoreSelection(item);
      }
      clear() {
        this.stack = {
          undo: [],
          redo: []
        };
      }
      cutoff() {
        this.lastRecorded = 0;
      }
      record(changeDelta, oldDelta) {
        if (changeDelta.ops.length === 0) return;
        this.stack.redo = [];
        let undoDelta = changeDelta.invert(oldDelta);
        let undoRange = this.currentRange;
        const timestamp = Date.now();
        if (
          // @ts-expect-error Fix me later
          this.lastRecorded + this.options.delay > timestamp && this.stack.undo.length > 0
        ) {
          const item = this.stack.undo.pop();
          if (item) {
            undoDelta = undoDelta.compose(item.delta);
            undoRange = item.range;
          }
        } else {
          this.lastRecorded = timestamp;
        }
        if (undoDelta.length() === 0) return;
        this.stack.undo.push({
          delta: undoDelta,
          range: undoRange
        });
        if (this.stack.undo.length > this.options.maxStack) {
          this.stack.undo.shift();
        }
      }
      redo() {
        this.change("redo", "undo");
      }
      transform(delta) {
        transformStack(this.stack.undo, delta);
        transformStack(this.stack.redo, delta);
      }
      undo() {
        this.change("undo", "redo");
      }
      restoreSelection(stackItem) {
        if (stackItem.range) {
          this.quill.setSelection(stackItem.range, Quill.sources.USER);
        } else {
          const index = getLastChangeIndex(this.quill.scroll, stackItem.delta);
          this.quill.setSelection(index, Quill.sources.USER);
        }
      }
    };
    __publicField(History, "DEFAULTS", {
      delay: 1e3,
      maxStack: 100,
      userOnly: false
    });
  }
});

// node_modules/quill/modules/uploader.js
var import_quill_delta4, Uploader, uploader_default;
var init_uploader = __esm({
  "node_modules/quill/modules/uploader.js"() {
    import_quill_delta4 = __toESM(require_Delta(), 1);
    init_emitter();
    init_module();
    Uploader = class extends module_default {
      constructor(quill, options) {
        super(quill, options);
        quill.root.addEventListener("drop", (e) => {
          var _a;
          e.preventDefault();
          let native = null;
          if (document.caretRangeFromPoint) {
            native = document.caretRangeFromPoint(e.clientX, e.clientY);
          } else if (document.caretPositionFromPoint) {
            const position = document.caretPositionFromPoint(e.clientX, e.clientY);
            native = document.createRange();
            native.setStart(position.offsetNode, position.offset);
            native.setEnd(position.offsetNode, position.offset);
          }
          const normalized = native && quill.selection.normalizeNative(native);
          if (normalized) {
            const range = quill.selection.normalizedToRange(normalized);
            if ((_a = e.dataTransfer) == null ? void 0 : _a.files) {
              this.upload(range, e.dataTransfer.files);
            }
          }
        });
      }
      upload(range, files) {
        const uploads = [];
        Array.from(files).forEach((file) => {
          var _a;
          if (file && ((_a = this.options.mimetypes) == null ? void 0 : _a.includes(file.type))) {
            uploads.push(file);
          }
        });
        if (uploads.length > 0) {
          this.options.handler.call(this, range, uploads);
        }
      }
    };
    Uploader.DEFAULTS = {
      mimetypes: ["image/png", "image/jpeg"],
      handler(range, files) {
        if (!this.quill.scroll.query("image")) {
          return;
        }
        const promises = files.map((file) => {
          return new Promise((resolve) => {
            const reader = new FileReader();
            reader.onload = () => {
              resolve(reader.result);
            };
            reader.readAsDataURL(file);
          });
        });
        Promise.all(promises).then((images) => {
          const update = images.reduce((delta, image) => {
            return delta.insert({
              image
            });
          }, new import_quill_delta4.default().retain(range.index).delete(range.length));
          this.quill.updateContents(update, emitter_default.sources.USER);
          this.quill.setSelection(range.index + images.length, emitter_default.sources.SILENT);
        });
      }
    };
    uploader_default = Uploader;
  }
});

// node_modules/quill/modules/input.js
function getPlainTextFromInputEvent(event) {
  var _a;
  if (typeof event.data === "string") {
    return event.data;
  }
  if ((_a = event.dataTransfer) == null ? void 0 : _a.types.includes("text/plain")) {
    return event.dataTransfer.getData("text/plain");
  }
  return null;
}
var import_quill_delta5, INSERT_TYPES, Input, input_default;
var init_input = __esm({
  "node_modules/quill/modules/input.js"() {
    import_quill_delta5 = __toESM(require_Delta(), 1);
    init_module();
    init_quill();
    init_keyboard();
    INSERT_TYPES = ["insertText", "insertReplacementText"];
    Input = class extends module_default {
      constructor(quill, options) {
        super(quill, options);
        quill.root.addEventListener("beforeinput", (event) => {
          this.handleBeforeInput(event);
        });
        if (!/Android/i.test(navigator.userAgent)) {
          quill.on(Quill.events.COMPOSITION_BEFORE_START, () => {
            this.handleCompositionStart();
          });
        }
      }
      deleteRange(range) {
        deleteRange({
          range,
          quill: this.quill
        });
      }
      replaceText(range) {
        let text = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
        if (range.length === 0) return false;
        if (text) {
          const formats = this.quill.getFormat(range.index, 1);
          this.deleteRange(range);
          this.quill.updateContents(new import_quill_delta5.default().retain(range.index).insert(text, formats), Quill.sources.USER);
        } else {
          this.deleteRange(range);
        }
        this.quill.setSelection(range.index + text.length, 0, Quill.sources.SILENT);
        return true;
      }
      handleBeforeInput(event) {
        if (this.quill.composition.isComposing || event.defaultPrevented || !INSERT_TYPES.includes(event.inputType)) {
          return;
        }
        const staticRange = event.getTargetRanges ? event.getTargetRanges()[0] : null;
        if (!staticRange || staticRange.collapsed === true) {
          return;
        }
        const text = getPlainTextFromInputEvent(event);
        if (text == null) {
          return;
        }
        const normalized = this.quill.selection.normalizeNative(staticRange);
        const range = normalized ? this.quill.selection.normalizedToRange(normalized) : null;
        if (range && this.replaceText(range, text)) {
          event.preventDefault();
        }
      }
      handleCompositionStart() {
        const range = this.quill.getSelection();
        if (range) {
          this.replaceText(range);
        }
      }
    };
    input_default = Input;
  }
});

// node_modules/quill/modules/uiNode.js
var isMac, TTL_FOR_VALID_SELECTION_CHANGE, canMoveCaretBeforeUINode, UINode, uiNode_default;
var init_uiNode = __esm({
  "node_modules/quill/modules/uiNode.js"() {
    init_parchment();
    init_module();
    init_quill();
    isMac = /Mac/i.test(navigator.platform);
    TTL_FOR_VALID_SELECTION_CHANGE = 100;
    canMoveCaretBeforeUINode = (event) => {
      if (event.key === "ArrowLeft" || event.key === "ArrowRight" || // RTL scripts or moving from the end of the previous line
      event.key === "ArrowUp" || event.key === "ArrowDown" || event.key === "Home") {
        return true;
      }
      if (isMac && event.key === "a" && event.ctrlKey === true) {
        return true;
      }
      return false;
    };
    UINode = class extends module_default {
      constructor(quill, options) {
        super(quill, options);
        __publicField(this, "isListening", false);
        __publicField(this, "selectionChangeDeadline", 0);
        this.handleArrowKeys();
        this.handleNavigationShortcuts();
      }
      handleArrowKeys() {
        this.quill.keyboard.addBinding({
          key: ["ArrowLeft", "ArrowRight"],
          offset: 0,
          shiftKey: null,
          handler(range, _ref) {
            let {
              line,
              event
            } = _ref;
            if (!(line instanceof ParentBlot$1) || !line.uiNode) {
              return true;
            }
            const isRTL = getComputedStyle(line.domNode)["direction"] === "rtl";
            if (isRTL && event.key !== "ArrowRight" || !isRTL && event.key !== "ArrowLeft") {
              return true;
            }
            this.quill.setSelection(range.index - 1, range.length + (event.shiftKey ? 1 : 0), Quill.sources.USER);
            return false;
          }
        });
      }
      handleNavigationShortcuts() {
        this.quill.root.addEventListener("keydown", (event) => {
          if (!event.defaultPrevented && canMoveCaretBeforeUINode(event)) {
            this.ensureListeningToSelectionChange();
          }
        });
      }
      /**
       * We only listen to the `selectionchange` event when
       * there is an intention of moving the caret to the beginning using shortcuts.
       * This is primarily implemented to prevent infinite loops, as we are changing
       * the selection within the handler of a `selectionchange` event.
       */
      ensureListeningToSelectionChange() {
        this.selectionChangeDeadline = Date.now() + TTL_FOR_VALID_SELECTION_CHANGE;
        if (this.isListening) return;
        this.isListening = true;
        const listener = () => {
          this.isListening = false;
          if (Date.now() <= this.selectionChangeDeadline) {
            this.handleSelectionChange();
          }
        };
        document.addEventListener("selectionchange", listener, {
          once: true
        });
      }
      handleSelectionChange() {
        const selection = document.getSelection();
        if (!selection) return;
        const range = selection.getRangeAt(0);
        if (range.collapsed !== true || range.startOffset !== 0) return;
        const line = this.quill.scroll.find(range.startContainer);
        if (!(line instanceof ParentBlot$1) || !line.uiNode) return;
        const newRange = document.createRange();
        newRange.setStartAfter(line.uiNode);
        newRange.setEndAfter(line.uiNode);
        selection.removeAllRanges();
        selection.addRange(newRange);
      }
    };
    uiNode_default = UINode;
  }
});

// node_modules/quill/core.js
var import_quill_delta6, core_default;
var init_core = __esm({
  "node_modules/quill/core.js"() {
    init_quill();
    init_block();
    init_break();
    init_container();
    init_cursor();
    init_embed();
    init_inline();
    init_scroll();
    init_text();
    init_clipboard();
    init_history();
    init_keyboard();
    init_uploader();
    import_quill_delta6 = __toESM(require_Delta(), 1);
    init_input();
    init_uiNode();
    init_module();
    Quill.register({
      "blots/block": Block,
      "blots/block/embed": BlockEmbed,
      "blots/break": break_default,
      "blots/container": container_default,
      "blots/cursor": cursor_default,
      "blots/embed": embed_default,
      "blots/inline": inline_default,
      "blots/scroll": scroll_default,
      "blots/text": Text,
      "modules/clipboard": Clipboard,
      "modules/history": History,
      "modules/keyboard": Keyboard,
      "modules/uploader": uploader_default,
      "modules/input": input_default,
      "modules/uiNode": uiNode_default
    });
    core_default = Quill;
  }
});

// node_modules/quill/formats/indent.js
var IndentAttributor, IndentClass, indent_default;
var init_indent = __esm({
  "node_modules/quill/formats/indent.js"() {
    init_parchment();
    IndentAttributor = class extends ClassAttributor$1 {
      add(node, value) {
        let normalizedValue = 0;
        if (value === "+1" || value === "-1") {
          const indent = this.value(node) || 0;
          normalizedValue = value === "+1" ? indent + 1 : indent - 1;
        } else if (typeof value === "number") {
          normalizedValue = value;
        }
        if (normalizedValue === 0) {
          this.remove(node);
          return true;
        }
        return super.add(node, normalizedValue.toString());
      }
      canAdd(node, value) {
        return super.canAdd(node, value) || super.canAdd(node, parseInt(value, 10));
      }
      value(node) {
        return parseInt(super.value(node), 10) || void 0;
      }
    };
    IndentClass = new IndentAttributor("indent", "ql-indent", {
      scope: Scope.BLOCK,
      // @ts-expect-error
      whitelist: [1, 2, 3, 4, 5, 6, 7, 8]
    });
    indent_default = IndentClass;
  }
});

// node_modules/quill/formats/blockquote.js
var Blockquote, blockquote_default;
var init_blockquote = __esm({
  "node_modules/quill/formats/blockquote.js"() {
    init_block();
    Blockquote = class extends Block {
    };
    __publicField(Blockquote, "blotName", "blockquote");
    __publicField(Blockquote, "tagName", "blockquote");
    blockquote_default = Blockquote;
  }
});

// node_modules/quill/formats/header.js
var Header, header_default;
var init_header = __esm({
  "node_modules/quill/formats/header.js"() {
    init_block();
    Header = class extends Block {
      static formats(domNode) {
        return this.tagName.indexOf(domNode.tagName) + 1;
      }
    };
    __publicField(Header, "blotName", "header");
    __publicField(Header, "tagName", ["H1", "H2", "H3", "H4", "H5", "H6"]);
    header_default = Header;
  }
});

// node_modules/quill/formats/list.js
var ListContainer, ListItem;
var init_list = __esm({
  "node_modules/quill/formats/list.js"() {
    init_block();
    init_container();
    init_quill();
    ListContainer = class extends container_default {
    };
    ListContainer.blotName = "list-container";
    ListContainer.tagName = "OL";
    ListItem = class extends Block {
      static create(value) {
        const node = super.create();
        node.setAttribute("data-list", value);
        return node;
      }
      static formats(domNode) {
        return domNode.getAttribute("data-list") || void 0;
      }
      static register() {
        Quill.register(ListContainer);
      }
      constructor(scroll, domNode) {
        super(scroll, domNode);
        const ui = domNode.ownerDocument.createElement("span");
        const listEventHandler = (e) => {
          if (!scroll.isEnabled()) return;
          const format = this.statics.formats(domNode, scroll);
          if (format === "checked") {
            this.format("list", "unchecked");
            e.preventDefault();
          } else if (format === "unchecked") {
            this.format("list", "checked");
            e.preventDefault();
          }
        };
        ui.addEventListener("mousedown", listEventHandler);
        ui.addEventListener("touchstart", listEventHandler);
        this.attachUI(ui);
      }
      format(name, value) {
        if (name === this.statics.blotName && value) {
          this.domNode.setAttribute("data-list", value);
        } else {
          super.format(name, value);
        }
      }
    };
    ListItem.blotName = "list";
    ListItem.tagName = "LI";
    ListContainer.allowedChildren = [ListItem];
    ListItem.requiredContainer = ListContainer;
  }
});

// node_modules/quill/formats/bold.js
var Bold, bold_default;
var init_bold = __esm({
  "node_modules/quill/formats/bold.js"() {
    init_inline();
    Bold = class extends inline_default {
      static create() {
        return super.create();
      }
      static formats() {
        return true;
      }
      optimize(context) {
        super.optimize(context);
        if (this.domNode.tagName !== this.statics.tagName[0]) {
          this.replaceWith(this.statics.blotName);
        }
      }
    };
    __publicField(Bold, "blotName", "bold");
    __publicField(Bold, "tagName", ["STRONG", "B"]);
    bold_default = Bold;
  }
});

// node_modules/quill/formats/italic.js
var Italic, italic_default;
var init_italic = __esm({
  "node_modules/quill/formats/italic.js"() {
    init_bold();
    Italic = class extends bold_default {
    };
    __publicField(Italic, "blotName", "italic");
    __publicField(Italic, "tagName", ["EM", "I"]);
    italic_default = Italic;
  }
});

// node_modules/quill/formats/link.js
function sanitize(url, protocols) {
  const anchor = document.createElement("a");
  anchor.href = url;
  const protocol = anchor.href.slice(0, anchor.href.indexOf(":"));
  return protocols.indexOf(protocol) > -1;
}
var Link;
var init_link = __esm({
  "node_modules/quill/formats/link.js"() {
    init_inline();
    Link = class extends inline_default {
      static create(value) {
        const node = super.create(value);
        node.setAttribute("href", this.sanitize(value));
        node.setAttribute("rel", "noopener noreferrer");
        node.setAttribute("target", "_blank");
        return node;
      }
      static formats(domNode) {
        return domNode.getAttribute("href");
      }
      static sanitize(url) {
        return sanitize(url, this.PROTOCOL_WHITELIST) ? url : this.SANITIZED_URL;
      }
      format(name, value) {
        if (name !== this.statics.blotName || !value) {
          super.format(name, value);
        } else {
          this.domNode.setAttribute("href", this.constructor.sanitize(value));
        }
      }
    };
    __publicField(Link, "blotName", "link");
    __publicField(Link, "tagName", "A");
    __publicField(Link, "SANITIZED_URL", "about:blank");
    __publicField(Link, "PROTOCOL_WHITELIST", ["http", "https", "mailto", "tel", "sms"]);
  }
});

// node_modules/quill/formats/script.js
var Script, script_default;
var init_script = __esm({
  "node_modules/quill/formats/script.js"() {
    init_inline();
    Script = class extends inline_default {
      static create(value) {
        if (value === "super") {
          return document.createElement("sup");
        }
        if (value === "sub") {
          return document.createElement("sub");
        }
        return super.create(value);
      }
      static formats(domNode) {
        if (domNode.tagName === "SUB") return "sub";
        if (domNode.tagName === "SUP") return "super";
        return void 0;
      }
    };
    __publicField(Script, "blotName", "script");
    __publicField(Script, "tagName", ["SUB", "SUP"]);
    script_default = Script;
  }
});

// node_modules/quill/formats/strike.js
var Strike, strike_default;
var init_strike = __esm({
  "node_modules/quill/formats/strike.js"() {
    init_bold();
    Strike = class extends bold_default {
    };
    __publicField(Strike, "blotName", "strike");
    __publicField(Strike, "tagName", ["S", "STRIKE"]);
    strike_default = Strike;
  }
});

// node_modules/quill/formats/underline.js
var Underline, underline_default;
var init_underline = __esm({
  "node_modules/quill/formats/underline.js"() {
    init_inline();
    Underline = class extends inline_default {
    };
    __publicField(Underline, "blotName", "underline");
    __publicField(Underline, "tagName", "U");
    underline_default = Underline;
  }
});

// node_modules/quill/formats/formula.js
var Formula, formula_default;
var init_formula = __esm({
  "node_modules/quill/formats/formula.js"() {
    init_embed();
    Formula = class extends embed_default {
      static create(value) {
        if (window.katex == null) {
          throw new Error("Formula module requires KaTeX.");
        }
        const node = super.create(value);
        if (typeof value === "string") {
          window.katex.render(value, node, {
            throwOnError: false,
            errorColor: "#f00"
          });
          node.setAttribute("data-value", value);
        }
        return node;
      }
      static value(domNode) {
        return domNode.getAttribute("data-value");
      }
      html() {
        const {
          formula
        } = this.value();
        return `<span>${formula}</span>`;
      }
    };
    __publicField(Formula, "blotName", "formula");
    __publicField(Formula, "className", "ql-formula");
    __publicField(Formula, "tagName", "SPAN");
    formula_default = Formula;
  }
});

// node_modules/quill/formats/image.js
var ATTRIBUTES, Image, image_default;
var init_image = __esm({
  "node_modules/quill/formats/image.js"() {
    init_parchment();
    init_link();
    ATTRIBUTES = ["alt", "height", "width"];
    Image = class extends EmbedBlot$1 {
      static create(value) {
        const node = super.create(value);
        if (typeof value === "string") {
          node.setAttribute("src", this.sanitize(value));
        }
        return node;
      }
      static formats(domNode) {
        return ATTRIBUTES.reduce((formats, attribute) => {
          if (domNode.hasAttribute(attribute)) {
            formats[attribute] = domNode.getAttribute(attribute);
          }
          return formats;
        }, {});
      }
      static match(url) {
        return /\.(jpe?g|gif|png)$/.test(url) || /^data:image\/.+;base64/.test(url);
      }
      static sanitize(url) {
        return sanitize(url, ["http", "https", "data"]) ? url : "//:0";
      }
      static value(domNode) {
        return domNode.getAttribute("src");
      }
      format(name, value) {
        if (ATTRIBUTES.indexOf(name) > -1) {
          if (value) {
            this.domNode.setAttribute(name, value);
          } else {
            this.domNode.removeAttribute(name);
          }
        } else {
          super.format(name, value);
        }
      }
    };
    __publicField(Image, "blotName", "image");
    __publicField(Image, "tagName", "IMG");
    image_default = Image;
  }
});

// node_modules/quill/formats/video.js
var ATTRIBUTES2, Video, video_default;
var init_video = __esm({
  "node_modules/quill/formats/video.js"() {
    init_block();
    init_link();
    ATTRIBUTES2 = ["height", "width"];
    Video = class extends BlockEmbed {
      static create(value) {
        const node = super.create(value);
        node.setAttribute("frameborder", "0");
        node.setAttribute("allowfullscreen", "true");
        node.setAttribute("src", this.sanitize(value));
        return node;
      }
      static formats(domNode) {
        return ATTRIBUTES2.reduce((formats, attribute) => {
          if (domNode.hasAttribute(attribute)) {
            formats[attribute] = domNode.getAttribute(attribute);
          }
          return formats;
        }, {});
      }
      static sanitize(url) {
        return Link.sanitize(url);
      }
      static value(domNode) {
        return domNode.getAttribute("src");
      }
      format(name, value) {
        if (ATTRIBUTES2.indexOf(name) > -1) {
          if (value) {
            this.domNode.setAttribute(name, value);
          } else {
            this.domNode.removeAttribute(name);
          }
        } else {
          super.format(name, value);
        }
      }
      html() {
        const {
          video
        } = this.value();
        return `<a href="${video}">${video}</a>`;
      }
    };
    __publicField(Video, "blotName", "video");
    __publicField(Video, "className", "ql-video");
    __publicField(Video, "tagName", "IFRAME");
    video_default = Video;
  }
});

// node_modules/quill/modules/syntax.js
var import_quill_delta7, TokenAttributor, CodeToken, SyntaxCodeBlock, SyntaxCodeBlockContainer, highlight, Syntax;
var init_syntax = __esm({
  "node_modules/quill/modules/syntax.js"() {
    import_quill_delta7 = __toESM(require_Delta(), 1);
    init_parchment();
    init_inline();
    init_quill();
    init_module();
    init_block();
    init_break();
    init_cursor();
    init_text();
    init_code();
    init_clipboard();
    TokenAttributor = new ClassAttributor$1("code-token", "hljs", {
      scope: Scope.INLINE
    });
    CodeToken = class _CodeToken extends inline_default {
      static formats(node, scroll) {
        while (node != null && node !== scroll.domNode) {
          if (node.classList && node.classList.contains(CodeBlock.className)) {
            return super.formats(node, scroll);
          }
          node = node.parentNode;
        }
        return void 0;
      }
      constructor(scroll, domNode, value) {
        super(scroll, domNode, value);
        TokenAttributor.add(this.domNode, value);
      }
      format(format, value) {
        if (format !== _CodeToken.blotName) {
          super.format(format, value);
        } else if (value) {
          TokenAttributor.add(this.domNode, value);
        } else {
          TokenAttributor.remove(this.domNode);
          this.domNode.classList.remove(this.statics.className);
        }
      }
      optimize() {
        super.optimize(...arguments);
        if (!TokenAttributor.value(this.domNode)) {
          this.unwrap();
        }
      }
    };
    CodeToken.blotName = "code-token";
    CodeToken.className = "ql-token";
    SyntaxCodeBlock = class extends CodeBlock {
      static create(value) {
        const domNode = super.create(value);
        if (typeof value === "string") {
          domNode.setAttribute("data-language", value);
        }
        return domNode;
      }
      static formats(domNode) {
        return domNode.getAttribute("data-language") || "plain";
      }
      static register() {
      }
      // Syntax module will register
      format(name, value) {
        if (name === this.statics.blotName && value) {
          this.domNode.setAttribute("data-language", value);
        } else {
          super.format(name, value);
        }
      }
      replaceWith(name, value) {
        this.formatAt(0, this.length(), CodeToken.blotName, false);
        return super.replaceWith(name, value);
      }
    };
    SyntaxCodeBlockContainer = class extends CodeBlockContainer {
      attach() {
        super.attach();
        this.forceNext = false;
        this.scroll.emitMount(this);
      }
      format(name, value) {
        if (name === SyntaxCodeBlock.blotName) {
          this.forceNext = true;
          this.children.forEach((child) => {
            child.format(name, value);
          });
        }
      }
      formatAt(index, length, name, value) {
        if (name === SyntaxCodeBlock.blotName) {
          this.forceNext = true;
        }
        super.formatAt(index, length, name, value);
      }
      highlight(highlight2) {
        let forced = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        if (this.children.head == null) return;
        const nodes = Array.from(this.domNode.childNodes).filter((node) => node !== this.uiNode);
        const text = `${nodes.map((node) => node.textContent).join("\n")}
`;
        const language = SyntaxCodeBlock.formats(this.children.head.domNode);
        if (forced || this.forceNext || this.cachedText !== text) {
          if (text.trim().length > 0 || this.cachedText == null) {
            const oldDelta = this.children.reduce((delta2, child) => {
              return delta2.concat(blockDelta(child, false));
            }, new import_quill_delta7.default());
            const delta = highlight2(text, language);
            oldDelta.diff(delta).reduce((index, _ref) => {
              let {
                retain,
                attributes
              } = _ref;
              if (!retain) return index;
              if (attributes) {
                Object.keys(attributes).forEach((format) => {
                  if ([SyntaxCodeBlock.blotName, CodeToken.blotName].includes(format)) {
                    this.formatAt(index, retain, format, attributes[format]);
                  }
                });
              }
              return index + retain;
            }, 0);
          }
          this.cachedText = text;
          this.forceNext = false;
        }
      }
      html(index, length) {
        const [codeBlock] = this.children.find(index);
        const language = codeBlock ? SyntaxCodeBlock.formats(codeBlock.domNode) : "plain";
        return `<pre data-language="${language}">
${escapeText(this.code(index, length))}
</pre>`;
      }
      optimize(context) {
        super.optimize(context);
        if (this.parent != null && this.children.head != null && this.uiNode != null) {
          const language = SyntaxCodeBlock.formats(this.children.head.domNode);
          if (language !== this.uiNode.value) {
            this.uiNode.value = language;
          }
        }
      }
    };
    SyntaxCodeBlockContainer.allowedChildren = [SyntaxCodeBlock];
    SyntaxCodeBlock.requiredContainer = SyntaxCodeBlockContainer;
    SyntaxCodeBlock.allowedChildren = [CodeToken, cursor_default, Text, break_default];
    highlight = (lib, language, text) => {
      if (typeof lib.versionString === "string") {
        const majorVersion = lib.versionString.split(".")[0];
        if (parseInt(majorVersion, 10) >= 11) {
          return lib.highlight(text, {
            language
          }).value;
        }
      }
      return lib.highlight(language, text).value;
    };
    Syntax = class extends module_default {
      static register() {
        Quill.register(CodeToken, true);
        Quill.register(SyntaxCodeBlock, true);
        Quill.register(SyntaxCodeBlockContainer, true);
      }
      constructor(quill, options) {
        super(quill, options);
        if (this.options.hljs == null) {
          throw new Error("Syntax module requires highlight.js. Please include the library on the page before Quill.");
        }
        this.languages = this.options.languages.reduce((memo, _ref2) => {
          let {
            key
          } = _ref2;
          memo[key] = true;
          return memo;
        }, {});
        this.highlightBlot = this.highlightBlot.bind(this);
        this.initListener();
        this.initTimer();
      }
      initListener() {
        this.quill.on(Quill.events.SCROLL_BLOT_MOUNT, (blot) => {
          if (!(blot instanceof SyntaxCodeBlockContainer)) return;
          const select = this.quill.root.ownerDocument.createElement("select");
          this.options.languages.forEach((_ref3) => {
            let {
              key,
              label
            } = _ref3;
            const option = select.ownerDocument.createElement("option");
            option.textContent = label;
            option.setAttribute("value", key);
            select.appendChild(option);
          });
          select.addEventListener("change", () => {
            blot.format(SyntaxCodeBlock.blotName, select.value);
            this.quill.root.focus();
            this.highlight(blot, true);
          });
          if (blot.uiNode == null) {
            blot.attachUI(select);
            if (blot.children.head) {
              select.value = SyntaxCodeBlock.formats(blot.children.head.domNode);
            }
          }
        });
      }
      initTimer() {
        let timer = null;
        this.quill.on(Quill.events.SCROLL_OPTIMIZE, () => {
          if (timer) {
            clearTimeout(timer);
          }
          timer = setTimeout(() => {
            this.highlight();
            timer = null;
          }, this.options.interval);
        });
      }
      highlight() {
        let blot = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        if (this.quill.selection.composing) return;
        this.quill.update(Quill.sources.USER);
        const range = this.quill.getSelection();
        const blots = blot == null ? this.quill.scroll.descendants(SyntaxCodeBlockContainer) : [blot];
        blots.forEach((container) => {
          container.highlight(this.highlightBlot, force);
        });
        this.quill.update(Quill.sources.SILENT);
        if (range != null) {
          this.quill.setSelection(range, Quill.sources.SILENT);
        }
      }
      highlightBlot(text) {
        let language = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "plain";
        language = this.languages[language] ? language : "plain";
        if (language === "plain") {
          return escapeText(text).split("\n").reduce((delta, line, i) => {
            if (i !== 0) {
              delta.insert("\n", {
                [CodeBlock.blotName]: language
              });
            }
            return delta.insert(line);
          }, new import_quill_delta7.default());
        }
        const container = this.quill.root.ownerDocument.createElement("div");
        container.classList.add(CodeBlock.className);
        container.innerHTML = highlight(this.options.hljs, language, text);
        return traverse(this.quill.scroll, container, [(node, delta) => {
          const value = TokenAttributor.value(node);
          if (value) {
            return delta.compose(new import_quill_delta7.default().retain(delta.length(), {
              [CodeToken.blotName]: value
            }));
          }
          return delta;
        }], [(node, delta) => {
          return node.data.split("\n").reduce((memo, nodeText, i) => {
            if (i !== 0) memo.insert("\n", {
              [CodeBlock.blotName]: language
            });
            return memo.insert(nodeText);
          }, delta);
        }], /* @__PURE__ */ new WeakMap());
      }
    };
    Syntax.DEFAULTS = {
      hljs: (() => {
        return window.hljs;
      })(),
      interval: 1e3,
      languages: [{
        key: "plain",
        label: "Plain"
      }, {
        key: "bash",
        label: "Bash"
      }, {
        key: "cpp",
        label: "C++"
      }, {
        key: "cs",
        label: "C#"
      }, {
        key: "css",
        label: "CSS"
      }, {
        key: "diff",
        label: "Diff"
      }, {
        key: "xml",
        label: "HTML/XML"
      }, {
        key: "java",
        label: "Java"
      }, {
        key: "javascript",
        label: "JavaScript"
      }, {
        key: "markdown",
        label: "Markdown"
      }, {
        key: "php",
        label: "PHP"
      }, {
        key: "python",
        label: "Python"
      }, {
        key: "ruby",
        label: "Ruby"
      }, {
        key: "sql",
        label: "SQL"
      }]
    };
  }
});

// node_modules/quill/modules/toolbar.js
function addButton(container, format, value) {
  const input = document.createElement("button");
  input.setAttribute("type", "button");
  input.classList.add(`ql-${format}`);
  input.setAttribute("aria-pressed", "false");
  if (value != null) {
    input.value = value;
    input.setAttribute("aria-label", `${format}: ${value}`);
  } else {
    input.setAttribute("aria-label", format);
  }
  container.appendChild(input);
}
function addControls(container, groups) {
  if (!Array.isArray(groups[0])) {
    groups = [groups];
  }
  groups.forEach((controls) => {
    const group = document.createElement("span");
    group.classList.add("ql-formats");
    controls.forEach((control) => {
      if (typeof control === "string") {
        addButton(group, control);
      } else {
        const format = Object.keys(control)[0];
        const value = control[format];
        if (Array.isArray(value)) {
          addSelect(group, format, value);
        } else {
          addButton(group, format, value);
        }
      }
    });
    container.appendChild(group);
  });
}
function addSelect(container, format, values) {
  const input = document.createElement("select");
  input.classList.add(`ql-${format}`);
  values.forEach((value) => {
    const option = document.createElement("option");
    if (value !== false) {
      option.setAttribute("value", String(value));
    } else {
      option.setAttribute("selected", "selected");
    }
    input.appendChild(option);
  });
  container.appendChild(input);
}
var import_quill_delta8, debug3, Toolbar;
var init_toolbar = __esm({
  "node_modules/quill/modules/toolbar.js"() {
    import_quill_delta8 = __toESM(require_Delta(), 1);
    init_parchment();
    init_quill();
    init_logger();
    init_module();
    debug3 = logger_default("quill:toolbar");
    Toolbar = class extends module_default {
      constructor(quill, options) {
        var _a, _b;
        super(quill, options);
        if (Array.isArray(this.options.container)) {
          const container = document.createElement("div");
          container.setAttribute("role", "toolbar");
          addControls(container, this.options.container);
          (_b = (_a = quill.container) == null ? void 0 : _a.parentNode) == null ? void 0 : _b.insertBefore(container, quill.container);
          this.container = container;
        } else if (typeof this.options.container === "string") {
          this.container = document.querySelector(this.options.container);
        } else {
          this.container = this.options.container;
        }
        if (!(this.container instanceof HTMLElement)) {
          debug3.error("Container required for toolbar", this.options);
          return;
        }
        this.container.classList.add("ql-toolbar");
        this.controls = [];
        this.handlers = {};
        if (this.options.handlers) {
          Object.keys(this.options.handlers).forEach((format) => {
            var _a2;
            const handler = (_a2 = this.options.handlers) == null ? void 0 : _a2[format];
            if (handler) {
              this.addHandler(format, handler);
            }
          });
        }
        Array.from(this.container.querySelectorAll("button, select")).forEach((input) => {
          this.attach(input);
        });
        this.quill.on(Quill.events.EDITOR_CHANGE, () => {
          const [range] = this.quill.selection.getRange();
          this.update(range);
        });
      }
      addHandler(format, handler) {
        this.handlers[format] = handler;
      }
      attach(input) {
        let format = Array.from(input.classList).find((className) => {
          return className.indexOf("ql-") === 0;
        });
        if (!format) return;
        format = format.slice("ql-".length);
        if (input.tagName === "BUTTON") {
          input.setAttribute("type", "button");
        }
        if (this.handlers[format] == null && this.quill.scroll.query(format) == null) {
          debug3.warn("ignoring attaching to nonexistent format", format, input);
          return;
        }
        const eventName = input.tagName === "SELECT" ? "change" : "click";
        input.addEventListener(eventName, (e) => {
          let value;
          if (input.tagName === "SELECT") {
            if (input.selectedIndex < 0) return;
            const selected = input.options[input.selectedIndex];
            if (selected.hasAttribute("selected")) {
              value = false;
            } else {
              value = selected.value || false;
            }
          } else {
            if (input.classList.contains("ql-active")) {
              value = false;
            } else {
              value = input.value || !input.hasAttribute("value");
            }
            e.preventDefault();
          }
          this.quill.focus();
          const [range] = this.quill.selection.getRange();
          if (this.handlers[format] != null) {
            this.handlers[format].call(this, value);
          } else if (
            // @ts-expect-error
            this.quill.scroll.query(format).prototype instanceof EmbedBlot$1
          ) {
            value = prompt(`Enter ${format}`);
            if (!value) return;
            this.quill.updateContents(new import_quill_delta8.default().retain(range.index).delete(range.length).insert({
              [format]: value
            }), Quill.sources.USER);
          } else {
            this.quill.format(format, value, Quill.sources.USER);
          }
          this.update(range);
        });
        this.controls.push([format, input]);
      }
      update(range) {
        const formats = range == null ? {} : this.quill.getFormat(range);
        this.controls.forEach((pair) => {
          const [format, input] = pair;
          if (input.tagName === "SELECT") {
            let option = null;
            if (range == null) {
              option = null;
            } else if (formats[format] == null) {
              option = input.querySelector("option[selected]");
            } else if (!Array.isArray(formats[format])) {
              let value = formats[format];
              if (typeof value === "string") {
                value = value.replace(/"/g, '\\"');
              }
              option = input.querySelector(`option[value="${value}"]`);
            }
            if (option == null) {
              input.value = "";
              input.selectedIndex = -1;
            } else {
              option.selected = true;
            }
          } else if (range == null) {
            input.classList.remove("ql-active");
            input.setAttribute("aria-pressed", "false");
          } else if (input.hasAttribute("value")) {
            const value = formats[format];
            const isActive = value === input.getAttribute("value") || value != null && value.toString() === input.getAttribute("value") || value == null && !input.getAttribute("value");
            input.classList.toggle("ql-active", isActive);
            input.setAttribute("aria-pressed", isActive.toString());
          } else {
            const isActive = formats[format] != null;
            input.classList.toggle("ql-active", isActive);
            input.setAttribute("aria-pressed", isActive.toString());
          }
        });
      }
    };
    Toolbar.DEFAULTS = {};
    Toolbar.DEFAULTS = {
      container: null,
      handlers: {
        clean() {
          const range = this.quill.getSelection();
          if (range == null) return;
          if (range.length === 0) {
            const formats = this.quill.getFormat();
            Object.keys(formats).forEach((name) => {
              if (this.quill.scroll.query(name, Scope.INLINE) != null) {
                this.quill.format(name, false, Quill.sources.USER);
              }
            });
          } else {
            this.quill.removeFormat(range.index, range.length, Quill.sources.USER);
          }
        },
        direction(value) {
          const {
            align
          } = this.quill.getFormat();
          if (value === "rtl" && align == null) {
            this.quill.format("align", "right", Quill.sources.USER);
          } else if (!value && align === "right") {
            this.quill.format("align", false, Quill.sources.USER);
          }
          this.quill.format("direction", value, Quill.sources.USER);
        },
        indent(value) {
          const range = this.quill.getSelection();
          const formats = this.quill.getFormat(range);
          const indent = parseInt(formats.indent || 0, 10);
          if (value === "+1" || value === "-1") {
            let modifier = value === "+1" ? 1 : -1;
            if (formats.direction === "rtl") modifier *= -1;
            this.quill.format("indent", indent + modifier, Quill.sources.USER);
          }
        },
        link(value) {
          if (value === true) {
            value = prompt("Enter link URL:");
          }
          this.quill.format("link", value, Quill.sources.USER);
        },
        list(value) {
          const range = this.quill.getSelection();
          const formats = this.quill.getFormat(range);
          if (value === "check") {
            if (formats.list === "checked" || formats.list === "unchecked") {
              this.quill.format("list", false, Quill.sources.USER);
            } else {
              this.quill.format("list", "unchecked", Quill.sources.USER);
            }
          } else {
            this.quill.format("list", value, Quill.sources.USER);
          }
        }
      }
    };
  }
});

// node_modules/quill/ui/icons.js
var alignLeftIcon, alignCenterIcon, alignRightIcon, alignJustifyIcon, backgroundIcon, blockquoteIcon, boldIcon, cleanIcon, codeIcon, colorIcon, directionLeftToRightIcon, directionRightToLeftIcon, formulaIcon, headerIcon, header2Icon, header3Icon, header4Icon, header5Icon, header6Icon, italicIcon, imageIcon, indentIcon, outdentIcon, linkIcon, listBulletIcon, listCheckIcon, listOrderedIcon, subscriptIcon, superscriptIcon, strikeIcon, tableIcon, underlineIcon, videoIcon, icons_default;
var init_icons = __esm({
  "node_modules/quill/ui/icons.js"() {
    alignLeftIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="3" x2="15" y1="9" y2="9"/><line class="ql-stroke" x1="3" x2="13" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="9" y1="4" y2="4"/></svg>';
    alignCenterIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="15" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="14" x2="4" y1="14" y2="14"/><line class="ql-stroke" x1="12" x2="6" y1="4" y2="4"/></svg>';
    alignRightIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="15" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="15" x2="5" y1="14" y2="14"/><line class="ql-stroke" x1="15" x2="9" y1="4" y2="4"/></svg>';
    alignJustifyIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="15" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="15" x2="3" y1="14" y2="14"/><line class="ql-stroke" x1="15" x2="3" y1="4" y2="4"/></svg>';
    backgroundIcon = '<svg viewbox="0 0 18 18"><g class="ql-fill ql-color-label"><polygon points="6 6.868 6 6 5 6 5 7 5.942 7 6 6.868"/><rect height="1" width="1" x="4" y="4"/><polygon points="6.817 5 6 5 6 6 6.38 6 6.817 5"/><rect height="1" width="1" x="2" y="6"/><rect height="1" width="1" x="3" y="5"/><rect height="1" width="1" x="4" y="7"/><polygon points="4 11.439 4 11 3 11 3 12 3.755 12 4 11.439"/><rect height="1" width="1" x="2" y="12"/><rect height="1" width="1" x="2" y="9"/><rect height="1" width="1" x="2" y="15"/><polygon points="4.63 10 4 10 4 11 4.192 11 4.63 10"/><rect height="1" width="1" x="3" y="8"/><path d="M10.832,4.2L11,4.582V4H10.708A1.948,1.948,0,0,1,10.832,4.2Z"/><path d="M7,4.582L7.168,4.2A1.929,1.929,0,0,1,7.292,4H7V4.582Z"/><path d="M8,13H7.683l-0.351.8a1.933,1.933,0,0,1-.124.2H8V13Z"/><rect height="1" width="1" x="12" y="2"/><rect height="1" width="1" x="11" y="3"/><path d="M9,3H8V3.282A1.985,1.985,0,0,1,9,3Z"/><rect height="1" width="1" x="2" y="3"/><rect height="1" width="1" x="6" y="2"/><rect height="1" width="1" x="3" y="2"/><rect height="1" width="1" x="5" y="3"/><rect height="1" width="1" x="9" y="2"/><rect height="1" width="1" x="15" y="14"/><polygon points="13.447 10.174 13.469 10.225 13.472 10.232 13.808 11 14 11 14 10 13.37 10 13.447 10.174"/><rect height="1" width="1" x="13" y="7"/><rect height="1" width="1" x="15" y="5"/><rect height="1" width="1" x="14" y="6"/><rect height="1" width="1" x="15" y="8"/><rect height="1" width="1" x="14" y="9"/><path d="M3.775,14H3v1H4V14.314A1.97,1.97,0,0,1,3.775,14Z"/><rect height="1" width="1" x="14" y="3"/><polygon points="12 6.868 12 6 11.62 6 12 6.868"/><rect height="1" width="1" x="15" y="2"/><rect height="1" width="1" x="12" y="5"/><rect height="1" width="1" x="13" y="4"/><polygon points="12.933 9 13 9 13 8 12.495 8 12.933 9"/><rect height="1" width="1" x="9" y="14"/><rect height="1" width="1" x="8" y="15"/><path d="M6,14.926V15H7V14.316A1.993,1.993,0,0,1,6,14.926Z"/><rect height="1" width="1" x="5" y="15"/><path d="M10.668,13.8L10.317,13H10v1h0.792A1.947,1.947,0,0,1,10.668,13.8Z"/><rect height="1" width="1" x="11" y="15"/><path d="M14.332,12.2a1.99,1.99,0,0,1,.166.8H15V12H14.245Z"/><rect height="1" width="1" x="14" y="15"/><rect height="1" width="1" x="15" y="11"/></g><polyline class="ql-stroke" points="5.5 13 9 5 12.5 13"/><line class="ql-stroke" x1="11.63" x2="6.38" y1="11" y2="11"/></svg>';
    blockquoteIcon = '<svg viewbox="0 0 18 18"><rect class="ql-fill ql-stroke" height="3" width="3" x="4" y="5"/><rect class="ql-fill ql-stroke" height="3" width="3" x="11" y="5"/><path class="ql-even ql-fill ql-stroke" d="M7,8c0,4.031-3,5-3,5"/><path class="ql-even ql-fill ql-stroke" d="M14,8c0,4.031-3,5-3,5"/></svg>';
    boldIcon = '<svg viewbox="0 0 18 18"><path class="ql-stroke" d="M5,4H9.5A2.5,2.5,0,0,1,12,6.5v0A2.5,2.5,0,0,1,9.5,9H5A0,0,0,0,1,5,9V4A0,0,0,0,1,5,4Z"/><path class="ql-stroke" d="M5,9h5.5A2.5,2.5,0,0,1,13,11.5v0A2.5,2.5,0,0,1,10.5,14H5a0,0,0,0,1,0,0V9A0,0,0,0,1,5,9Z"/></svg>';
    cleanIcon = '<svg class="" viewbox="0 0 18 18"><line class="ql-stroke" x1="5" x2="13" y1="3" y2="3"/><line class="ql-stroke" x1="6" x2="9.35" y1="12" y2="3"/><line class="ql-stroke" x1="11" x2="15" y1="11" y2="15"/><line class="ql-stroke" x1="15" x2="11" y1="11" y2="15"/><rect class="ql-fill" height="1" rx="0.5" ry="0.5" width="7" x="2" y="14"/></svg>';
    codeIcon = '<svg viewbox="0 0 18 18"><polyline class="ql-even ql-stroke" points="5 7 3 9 5 11"/><polyline class="ql-even ql-stroke" points="13 7 15 9 13 11"/><line class="ql-stroke" x1="10" x2="8" y1="5" y2="13"/></svg>';
    colorIcon = '<svg viewbox="0 0 18 18"><line class="ql-color-label ql-stroke ql-transparent" x1="3" x2="15" y1="15" y2="15"/><polyline class="ql-stroke" points="5.5 11 9 3 12.5 11"/><line class="ql-stroke" x1="11.63" x2="6.38" y1="9" y2="9"/></svg>';
    directionLeftToRightIcon = '<svg viewbox="0 0 18 18"><polygon class="ql-stroke ql-fill" points="3 11 5 9 3 7 3 11"/><line class="ql-stroke ql-fill" x1="15" x2="11" y1="4" y2="4"/><path class="ql-fill" d="M11,3a3,3,0,0,0,0,6h1V3H11Z"/><rect class="ql-fill" height="11" width="1" x="11" y="4"/><rect class="ql-fill" height="11" width="1" x="13" y="4"/></svg>';
    directionRightToLeftIcon = '<svg viewbox="0 0 18 18"><polygon class="ql-stroke ql-fill" points="15 12 13 10 15 8 15 12"/><line class="ql-stroke ql-fill" x1="9" x2="5" y1="4" y2="4"/><path class="ql-fill" d="M5,3A3,3,0,0,0,5,9H6V3H5Z"/><rect class="ql-fill" height="11" width="1" x="5" y="4"/><rect class="ql-fill" height="11" width="1" x="7" y="4"/></svg>';
    formulaIcon = '<svg viewbox="0 0 18 18"><path class="ql-fill" d="M11.759,2.482a2.561,2.561,0,0,0-3.53.607A7.656,7.656,0,0,0,6.8,6.2C6.109,9.188,5.275,14.677,4.15,14.927a1.545,1.545,0,0,0-1.3-.933A0.922,0.922,0,0,0,2,15.036S1.954,16,4.119,16s3.091-2.691,3.7-5.553c0.177-.826.36-1.726,0.554-2.6L8.775,6.2c0.381-1.421.807-2.521,1.306-2.676a1.014,1.014,0,0,0,1.02.56A0.966,0.966,0,0,0,11.759,2.482Z"/><rect class="ql-fill" height="1.6" rx="0.8" ry="0.8" width="5" x="5.15" y="6.2"/><path class="ql-fill" d="M13.663,12.027a1.662,1.662,0,0,1,.266-0.276q0.193,0.069.456,0.138a2.1,2.1,0,0,0,.535.069,1.075,1.075,0,0,0,.767-0.3,1.044,1.044,0,0,0,.314-0.8,0.84,0.84,0,0,0-.238-0.619,0.8,0.8,0,0,0-.594-0.239,1.154,1.154,0,0,0-.781.3,4.607,4.607,0,0,0-.781,1q-0.091.15-.218,0.346l-0.246.38c-0.068-.288-0.137-0.582-0.212-0.885-0.459-1.847-2.494-.984-2.941-0.8-0.482.2-.353,0.647-0.094,0.529a0.869,0.869,0,0,1,1.281.585c0.217,0.751.377,1.436,0.527,2.038a5.688,5.688,0,0,1-.362.467,2.69,2.69,0,0,1-.264.271q-0.221-.08-0.471-0.147a2.029,2.029,0,0,0-.522-0.066,1.079,1.079,0,0,0-.768.3A1.058,1.058,0,0,0,9,15.131a0.82,0.82,0,0,0,.832.852,1.134,1.134,0,0,0,.787-0.3,5.11,5.11,0,0,0,.776-0.993q0.141-.219.215-0.34c0.046-.076.122-0.194,0.223-0.346a2.786,2.786,0,0,0,.918,1.726,2.582,2.582,0,0,0,2.376-.185c0.317-.181.212-0.565,0-0.494A0.807,0.807,0,0,1,14.176,15a5.159,5.159,0,0,1-.913-2.446l0,0Q13.487,12.24,13.663,12.027Z"/></svg>';
    headerIcon = '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm6.06787,9.209H14.98975V7.59863a.54085.54085,0,0,0-.605-.60547h-.62744a1.01119,1.01119,0,0,0-.748.29688L11.645,8.56641a.5435.5435,0,0,0-.022.8584l.28613.30762a.53861.53861,0,0,0,.84717.0332l.09912-.08789a1.2137,1.2137,0,0,0,.2417-.35254h.02246s-.01123.30859-.01123.60547V13.209H12.041a.54085.54085,0,0,0-.605.60547v.43945a.54085.54085,0,0,0,.605.60547h4.02686a.54085.54085,0,0,0,.605-.60547v-.43945A.54085.54085,0,0,0,16.06787,13.209Z"/></svg>';
    header2Icon = '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M16.73975,13.81445v.43945a.54085.54085,0,0,1-.605.60547H11.855a.58392.58392,0,0,1-.64893-.60547V14.0127c0-2.90527,3.39941-3.42187,3.39941-4.55469a.77675.77675,0,0,0-.84717-.78125,1.17684,1.17684,0,0,0-.83594.38477c-.2749.26367-.561.374-.85791.13184l-.4292-.34082c-.30811-.24219-.38525-.51758-.1543-.81445a2.97155,2.97155,0,0,1,2.45361-1.17676,2.45393,2.45393,0,0,1,2.68408,2.40918c0,2.45312-3.1792,2.92676-3.27832,3.93848h2.79443A.54085.54085,0,0,1,16.73975,13.81445ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z"/></svg>';
    header3Icon = '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M16.65186,12.30664a2.6742,2.6742,0,0,1-2.915,2.68457,3.96592,3.96592,0,0,1-2.25537-.6709.56007.56007,0,0,1-.13232-.83594L11.64648,13c.209-.34082.48389-.36328.82471-.1543a2.32654,2.32654,0,0,0,1.12256.33008c.71484,0,1.12207-.35156,1.12207-.78125,0-.61523-.61621-.86816-1.46338-.86816H13.2085a.65159.65159,0,0,1-.68213-.41895l-.05518-.10937a.67114.67114,0,0,1,.14307-.78125l.71533-.86914a8.55289,8.55289,0,0,1,.68213-.7373V8.58887a3.93913,3.93913,0,0,1-.748.05469H11.9873a.54085.54085,0,0,1-.605-.60547V7.59863a.54085.54085,0,0,1,.605-.60547h3.75146a.53773.53773,0,0,1,.60547.59375v.17676a1.03723,1.03723,0,0,1-.27539.748L14.74854,10.0293A2.31132,2.31132,0,0,1,16.65186,12.30664ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z"/></svg>';
    header4Icon = '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm7.05371,7.96582v.38477c0,.39648-.165.60547-.46191.60547h-.47314v1.29785a.54085.54085,0,0,1-.605.60547h-.69336a.54085.54085,0,0,1-.605-.60547V12.95605H11.333a.5412.5412,0,0,1-.60547-.60547v-.15332a1.199,1.199,0,0,1,.22021-.748l2.56348-4.05957a.7819.7819,0,0,1,.72607-.39648h1.27637a.54085.54085,0,0,1,.605.60547v3.7627h.33008A.54055.54055,0,0,1,17.05371,11.96582ZM14.28125,8.7207h-.022a4.18969,4.18969,0,0,1-.38525.81348l-1.188,1.80469v.02246h1.5293V9.60059A7.04058,7.04058,0,0,1,14.28125,8.7207Z"/></svg>';
    header5Icon = '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M16.74023,12.18555a2.75131,2.75131,0,0,1-2.91553,2.80566,3.908,3.908,0,0,1-2.25537-.68164.54809.54809,0,0,1-.13184-.8252L11.73438,13c.209-.34082.48389-.36328.8252-.1543a2.23757,2.23757,0,0,0,1.1001.33008,1.01827,1.01827,0,0,0,1.1001-.96777c0-.61621-.53906-.97949-1.25439-.97949a2.15554,2.15554,0,0,0-.64893.09961,1.15209,1.15209,0,0,1-.814.01074l-.12109-.04395a.64116.64116,0,0,1-.45117-.71484l.231-3.00391a.56666.56666,0,0,1,.62744-.583H15.541a.54085.54085,0,0,1,.605.60547v.43945a.54085.54085,0,0,1-.605.60547H13.41748l-.04395.72559a1.29306,1.29306,0,0,1-.04395.30859h.022a2.39776,2.39776,0,0,1,.57227-.07715A2.53266,2.53266,0,0,1,16.74023,12.18555ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z"/></svg>';
    header6Icon = '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M14.51758,9.64453a1.85627,1.85627,0,0,0-1.24316.38477H13.252a1.73532,1.73532,0,0,1,1.72754-1.4082,2.66491,2.66491,0,0,1,.5498.06641c.35254.05469.57227.01074.70508-.40723l.16406-.5166a.53393.53393,0,0,0-.373-.75977,4.83723,4.83723,0,0,0-1.17773-.14258c-2.43164,0-3.7627,2.17773-3.7627,4.43359,0,2.47559,1.60645,3.69629,3.19043,3.69629A2.70585,2.70585,0,0,0,16.96,12.19727,2.43861,2.43861,0,0,0,14.51758,9.64453Zm-.23047,3.58691c-.67187,0-1.22168-.81445-1.22168-1.45215,0-.47363.30762-.583.72559-.583.96875,0,1.27734.59375,1.27734,1.12207A.82182.82182,0,0,1,14.28711,13.23145ZM10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Z"/></svg>';
    italicIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="7" x2="13" y1="4" y2="4"/><line class="ql-stroke" x1="5" x2="11" y1="14" y2="14"/><line class="ql-stroke" x1="8" x2="10" y1="14" y2="4"/></svg>';
    imageIcon = '<svg viewbox="0 0 18 18"><rect class="ql-stroke" height="10" width="12" x="3" y="4"/><circle class="ql-fill" cx="6" cy="7" r="1"/><polyline class="ql-even ql-fill" points="5 12 5 11 7 9 8 10 11 7 13 9 13 12 5 12"/></svg>';
    indentIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="3" x2="15" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="9" x2="15" y1="9" y2="9"/><polyline class="ql-fill ql-stroke" points="3 7 3 11 5 9 3 7"/></svg>';
    outdentIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="3" x2="15" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="9" x2="15" y1="9" y2="9"/><polyline class="ql-stroke" points="5 7 5 11 3 9 5 7"/></svg>';
    linkIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="7" x2="11" y1="7" y2="11"/><path class="ql-even ql-stroke" d="M8.9,4.577a3.476,3.476,0,0,1,.36,4.679A3.476,3.476,0,0,1,4.577,8.9C3.185,7.5,2.035,6.4,4.217,4.217S7.5,3.185,8.9,4.577Z"/><path class="ql-even ql-stroke" d="M13.423,9.1a3.476,3.476,0,0,0-4.679-.36,3.476,3.476,0,0,0,.36,4.679c1.392,1.392,2.5,2.542,4.679.36S14.815,10.5,13.423,9.1Z"/></svg>';
    listBulletIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="6" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="6" x2="15" y1="9" y2="9"/><line class="ql-stroke" x1="6" x2="15" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="3" y1="4" y2="4"/><line class="ql-stroke" x1="3" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="3" x2="3" y1="14" y2="14"/></svg>';
    listCheckIcon = '<svg class="" viewbox="0 0 18 18"><line class="ql-stroke" x1="9" x2="15" y1="4" y2="4"/><polyline class="ql-stroke" points="3 4 4 5 6 3"/><line class="ql-stroke" x1="9" x2="15" y1="14" y2="14"/><polyline class="ql-stroke" points="3 14 4 15 6 13"/><line class="ql-stroke" x1="9" x2="15" y1="9" y2="9"/><polyline class="ql-stroke" points="3 9 4 10 6 8"/></svg>';
    listOrderedIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="7" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="7" x2="15" y1="9" y2="9"/><line class="ql-stroke" x1="7" x2="15" y1="14" y2="14"/><line class="ql-stroke ql-thin" x1="2.5" x2="4.5" y1="5.5" y2="5.5"/><path class="ql-fill" d="M3.5,6A0.5,0.5,0,0,1,3,5.5V3.085l-0.276.138A0.5,0.5,0,0,1,2.053,3c-0.124-.247-0.023-0.324.224-0.447l1-.5A0.5,0.5,0,0,1,4,2.5v3A0.5,0.5,0,0,1,3.5,6Z"/><path class="ql-stroke ql-thin" d="M4.5,10.5h-2c0-.234,1.85-1.076,1.85-2.234A0.959,0.959,0,0,0,2.5,8.156"/><path class="ql-stroke ql-thin" d="M2.5,14.846a0.959,0.959,0,0,0,1.85-.109A0.7,0.7,0,0,0,3.75,14a0.688,0.688,0,0,0,.6-0.736,0.959,0.959,0,0,0-1.85-.109"/></svg>';
    subscriptIcon = '<svg viewbox="0 0 18 18"><path class="ql-fill" d="M15.5,15H13.861a3.858,3.858,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.921,1.921,0,0,0,12.021,11.7a0.50013,0.50013,0,1,0,.957.291h0a0.914,0.914,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.076-1.16971,1.86982-1.93971,2.43082A1.45639,1.45639,0,0,0,12,15.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,15Z"/><path class="ql-fill" d="M9.65,5.241a1,1,0,0,0-1.409.108L6,7.964,3.759,5.349A1,1,0,0,0,2.192,6.59178Q2.21541,6.6213,2.241,6.649L4.684,9.5,2.241,12.35A1,1,0,0,0,3.71,13.70722q0.02557-.02768.049-0.05722L6,11.036,8.241,13.65a1,1,0,1,0,1.567-1.24277Q9.78459,12.3777,9.759,12.35L7.316,9.5,9.759,6.651A1,1,0,0,0,9.65,5.241Z"/></svg>';
    superscriptIcon = '<svg viewbox="0 0 18 18"><path class="ql-fill" d="M15.5,7H13.861a4.015,4.015,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.922,1.922,0,0,0,12.021,3.7a0.5,0.5,0,1,0,.957.291,0.917,0.917,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.077-1.164,1.925-1.934,2.486A1.423,1.423,0,0,0,12,7.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,7Z"/><path class="ql-fill" d="M9.651,5.241a1,1,0,0,0-1.41.108L6,7.964,3.759,5.349a1,1,0,1,0-1.519,1.3L4.683,9.5,2.241,12.35a1,1,0,1,0,1.519,1.3L6,11.036,8.241,13.65a1,1,0,0,0,1.519-1.3L7.317,9.5,9.759,6.651A1,1,0,0,0,9.651,5.241Z"/></svg>';
    strikeIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke ql-thin" x1="15.5" x2="2.5" y1="8.5" y2="9.5"/><path class="ql-fill" d="M9.007,8C6.542,7.791,6,7.519,6,6.5,6,5.792,7.283,5,9,5c1.571,0,2.765.679,2.969,1.309a1,1,0,0,0,1.9-.617C13.356,4.106,11.354,3,9,3,6.2,3,4,4.538,4,6.5a3.2,3.2,0,0,0,.5,1.843Z"/><path class="ql-fill" d="M8.984,10C11.457,10.208,12,10.479,12,11.5c0,0.708-1.283,1.5-3,1.5-1.571,0-2.765-.679-2.969-1.309a1,1,0,1,0-1.9.617C4.644,13.894,6.646,15,9,15c2.8,0,5-1.538,5-3.5a3.2,3.2,0,0,0-.5-1.843Z"/></svg>';
    tableIcon = '<svg viewbox="0 0 18 18"><rect class="ql-stroke" height="12" width="12" x="3" y="3"/><rect class="ql-fill" height="2" width="3" x="5" y="5"/><rect class="ql-fill" height="2" width="4" x="9" y="5"/><g class="ql-fill ql-transparent"><rect height="2" width="3" x="5" y="8"/><rect height="2" width="4" x="9" y="8"/><rect height="2" width="3" x="5" y="11"/><rect height="2" width="4" x="9" y="11"/></g></svg>';
    underlineIcon = '<svg viewbox="0 0 18 18"><path class="ql-stroke" d="M5,3V9a4.012,4.012,0,0,0,4,4H9a4.012,4.012,0,0,0,4-4V3"/><rect class="ql-fill" height="1" rx="0.5" ry="0.5" width="12" x="3" y="15"/></svg>';
    videoIcon = '<svg viewbox="0 0 18 18"><rect class="ql-stroke" height="12" width="12" x="3" y="3"/><rect class="ql-fill" height="12" width="1" x="5" y="3"/><rect class="ql-fill" height="12" width="1" x="12" y="3"/><rect class="ql-fill" height="2" width="8" x="5" y="8"/><rect class="ql-fill" height="1" width="3" x="3" y="5"/><rect class="ql-fill" height="1" width="3" x="3" y="7"/><rect class="ql-fill" height="1" width="3" x="3" y="10"/><rect class="ql-fill" height="1" width="3" x="3" y="12"/><rect class="ql-fill" height="1" width="3" x="12" y="5"/><rect class="ql-fill" height="1" width="3" x="12" y="7"/><rect class="ql-fill" height="1" width="3" x="12" y="10"/><rect class="ql-fill" height="1" width="3" x="12" y="12"/></svg>';
    icons_default = {
      align: {
        "": alignLeftIcon,
        center: alignCenterIcon,
        right: alignRightIcon,
        justify: alignJustifyIcon
      },
      background: backgroundIcon,
      blockquote: blockquoteIcon,
      bold: boldIcon,
      clean: cleanIcon,
      code: codeIcon,
      "code-block": codeIcon,
      color: colorIcon,
      direction: {
        "": directionLeftToRightIcon,
        rtl: directionRightToLeftIcon
      },
      formula: formulaIcon,
      header: {
        "1": headerIcon,
        "2": header2Icon,
        "3": header3Icon,
        "4": header4Icon,
        "5": header5Icon,
        "6": header6Icon
      },
      italic: italicIcon,
      image: imageIcon,
      indent: {
        "+1": indentIcon,
        "-1": outdentIcon
      },
      link: linkIcon,
      list: {
        bullet: listBulletIcon,
        check: listCheckIcon,
        ordered: listOrderedIcon
      },
      script: {
        sub: subscriptIcon,
        super: superscriptIcon
      },
      strike: strikeIcon,
      table: tableIcon,
      underline: underlineIcon,
      video: videoIcon
    };
  }
});

// node_modules/quill/ui/picker.js
function toggleAriaAttribute(element, attribute) {
  element.setAttribute(attribute, `${!(element.getAttribute(attribute) === "true")}`);
}
var DropdownIcon, optionsCounter, Picker, picker_default;
var init_picker = __esm({
  "node_modules/quill/ui/picker.js"() {
    DropdownIcon = '<svg viewbox="0 0 18 18"><polygon class="ql-stroke" points="7 11 9 13 11 11 7 11"/><polygon class="ql-stroke" points="7 7 9 5 11 7 7 7"/></svg>';
    optionsCounter = 0;
    Picker = class {
      constructor(select) {
        this.select = select;
        this.container = document.createElement("span");
        this.buildPicker();
        this.select.style.display = "none";
        this.select.parentNode.insertBefore(this.container, this.select);
        this.label.addEventListener("mousedown", () => {
          this.togglePicker();
        });
        this.label.addEventListener("keydown", (event) => {
          switch (event.key) {
            case "Enter":
              this.togglePicker();
              break;
            case "Escape":
              this.escape();
              event.preventDefault();
              break;
            default:
          }
        });
        this.select.addEventListener("change", this.update.bind(this));
      }
      togglePicker() {
        this.container.classList.toggle("ql-expanded");
        toggleAriaAttribute(this.label, "aria-expanded");
        toggleAriaAttribute(this.options, "aria-hidden");
      }
      buildItem(option) {
        const item = document.createElement("span");
        item.tabIndex = "0";
        item.setAttribute("role", "button");
        item.classList.add("ql-picker-item");
        const value = option.getAttribute("value");
        if (value) {
          item.setAttribute("data-value", value);
        }
        if (option.textContent) {
          item.setAttribute("data-label", option.textContent);
        }
        item.addEventListener("click", () => {
          this.selectItem(item, true);
        });
        item.addEventListener("keydown", (event) => {
          switch (event.key) {
            case "Enter":
              this.selectItem(item, true);
              event.preventDefault();
              break;
            case "Escape":
              this.escape();
              event.preventDefault();
              break;
            default:
          }
        });
        return item;
      }
      buildLabel() {
        const label = document.createElement("span");
        label.classList.add("ql-picker-label");
        label.innerHTML = DropdownIcon;
        label.tabIndex = "0";
        label.setAttribute("role", "button");
        label.setAttribute("aria-expanded", "false");
        this.container.appendChild(label);
        return label;
      }
      buildOptions() {
        const options = document.createElement("span");
        options.classList.add("ql-picker-options");
        options.setAttribute("aria-hidden", "true");
        options.tabIndex = "-1";
        options.id = `ql-picker-options-${optionsCounter}`;
        optionsCounter += 1;
        this.label.setAttribute("aria-controls", options.id);
        this.options = options;
        Array.from(this.select.options).forEach((option) => {
          const item = this.buildItem(option);
          options.appendChild(item);
          if (option.selected === true) {
            this.selectItem(item);
          }
        });
        this.container.appendChild(options);
      }
      buildPicker() {
        Array.from(this.select.attributes).forEach((item) => {
          this.container.setAttribute(item.name, item.value);
        });
        this.container.classList.add("ql-picker");
        this.label = this.buildLabel();
        this.buildOptions();
      }
      escape() {
        this.close();
        setTimeout(() => this.label.focus(), 1);
      }
      close() {
        this.container.classList.remove("ql-expanded");
        this.label.setAttribute("aria-expanded", "false");
        this.options.setAttribute("aria-hidden", "true");
      }
      selectItem(item) {
        let trigger = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        const selected = this.container.querySelector(".ql-selected");
        if (item === selected) return;
        if (selected != null) {
          selected.classList.remove("ql-selected");
        }
        if (item == null) return;
        item.classList.add("ql-selected");
        this.select.selectedIndex = Array.from(item.parentNode.children).indexOf(item);
        if (item.hasAttribute("data-value")) {
          this.label.setAttribute("data-value", item.getAttribute("data-value"));
        } else {
          this.label.removeAttribute("data-value");
        }
        if (item.hasAttribute("data-label")) {
          this.label.setAttribute("data-label", item.getAttribute("data-label"));
        } else {
          this.label.removeAttribute("data-label");
        }
        if (trigger) {
          this.select.dispatchEvent(new Event("change"));
          this.close();
        }
      }
      update() {
        let option;
        if (this.select.selectedIndex > -1) {
          const item = (
            // @ts-expect-error Fix me later
            this.container.querySelector(".ql-picker-options").children[this.select.selectedIndex]
          );
          option = this.select.options[this.select.selectedIndex];
          this.selectItem(item);
        } else {
          this.selectItem(null);
        }
        const isActive = option != null && option !== this.select.querySelector("option[selected]");
        this.label.classList.toggle("ql-active", isActive);
      }
    };
    picker_default = Picker;
  }
});

// node_modules/quill/ui/color-picker.js
var ColorPicker, color_picker_default;
var init_color_picker = __esm({
  "node_modules/quill/ui/color-picker.js"() {
    init_picker();
    ColorPicker = class extends picker_default {
      constructor(select, label) {
        super(select);
        this.label.innerHTML = label;
        this.container.classList.add("ql-color-picker");
        Array.from(this.container.querySelectorAll(".ql-picker-item")).slice(0, 7).forEach((item) => {
          item.classList.add("ql-primary");
        });
      }
      buildItem(option) {
        const item = super.buildItem(option);
        item.style.backgroundColor = option.getAttribute("value") || "";
        return item;
      }
      selectItem(item, trigger) {
        super.selectItem(item, trigger);
        const colorLabel = this.label.querySelector(".ql-color-label");
        const value = item ? item.getAttribute("data-value") || "" : "";
        if (colorLabel) {
          if (colorLabel.tagName === "line") {
            colorLabel.style.stroke = value;
          } else {
            colorLabel.style.fill = value;
          }
        }
      }
    };
    color_picker_default = ColorPicker;
  }
});

// node_modules/quill/ui/icon-picker.js
var IconPicker, icon_picker_default;
var init_icon_picker = __esm({
  "node_modules/quill/ui/icon-picker.js"() {
    init_picker();
    IconPicker = class extends picker_default {
      constructor(select, icons) {
        super(select);
        this.container.classList.add("ql-icon-picker");
        Array.from(this.container.querySelectorAll(".ql-picker-item")).forEach((item) => {
          item.innerHTML = icons[item.getAttribute("data-value") || ""];
        });
        this.defaultItem = this.container.querySelector(".ql-selected");
        this.selectItem(this.defaultItem);
      }
      selectItem(target, trigger) {
        super.selectItem(target, trigger);
        const item = target || this.defaultItem;
        if (item != null) {
          if (this.label.innerHTML === item.innerHTML) return;
          this.label.innerHTML = item.innerHTML;
        }
      }
    };
    icon_picker_default = IconPicker;
  }
});

// node_modules/quill/ui/tooltip.js
var isScrollable, Tooltip, tooltip_default;
var init_tooltip = __esm({
  "node_modules/quill/ui/tooltip.js"() {
    isScrollable = (el) => {
      const {
        overflowY
      } = getComputedStyle(el, null);
      return overflowY !== "visible" && overflowY !== "clip";
    };
    Tooltip = class {
      constructor(quill, boundsContainer) {
        this.quill = quill;
        this.boundsContainer = boundsContainer || document.body;
        this.root = quill.addContainer("ql-tooltip");
        this.root.innerHTML = this.constructor.TEMPLATE;
        if (isScrollable(this.quill.root)) {
          this.quill.root.addEventListener("scroll", () => {
            this.root.style.marginTop = `${-1 * this.quill.root.scrollTop}px`;
          });
        }
        this.hide();
      }
      hide() {
        this.root.classList.add("ql-hidden");
      }
      position(reference) {
        const left = reference.left + reference.width / 2 - this.root.offsetWidth / 2;
        const top = reference.bottom + this.quill.root.scrollTop;
        this.root.style.left = `${left}px`;
        this.root.style.top = `${top}px`;
        this.root.classList.remove("ql-flip");
        const containerBounds = this.boundsContainer.getBoundingClientRect();
        const rootBounds = this.root.getBoundingClientRect();
        let shift = 0;
        if (rootBounds.right > containerBounds.right) {
          shift = containerBounds.right - rootBounds.right;
          this.root.style.left = `${left + shift}px`;
        }
        if (rootBounds.left < containerBounds.left) {
          shift = containerBounds.left - rootBounds.left;
          this.root.style.left = `${left + shift}px`;
        }
        if (rootBounds.bottom > containerBounds.bottom) {
          const height = rootBounds.bottom - rootBounds.top;
          const verticalShift = reference.bottom - reference.top + height;
          this.root.style.top = `${top - verticalShift}px`;
          this.root.classList.add("ql-flip");
        }
        return shift;
      }
      show() {
        this.root.classList.remove("ql-editing");
        this.root.classList.remove("ql-hidden");
      }
    };
    tooltip_default = Tooltip;
  }
});

// node_modules/quill/themes/base.js
function extractVideoUrl(url) {
  let match = url.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtube\.com\/watch.*v=([a-zA-Z0-9_-]+)/) || url.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtu\.be\/([a-zA-Z0-9_-]+)/);
  if (match) {
    return `${match[1] || "https"}://www.youtube.com/embed/${match[2]}?showinfo=0`;
  }
  if (match = url.match(/^(?:(https?):\/\/)?(?:www\.)?vimeo\.com\/(\d+)/)) {
    return `${match[1] || "https"}://player.vimeo.com/video/${match[2]}/`;
  }
  return url;
}
function fillSelect(select, values) {
  let defaultValue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  values.forEach((value) => {
    const option = document.createElement("option");
    if (value === defaultValue) {
      option.setAttribute("selected", "selected");
    } else {
      option.setAttribute("value", String(value));
    }
    select.appendChild(option);
  });
}
var ALIGNS, COLORS, FONTS, HEADERS, SIZES, BaseTheme, BaseTooltip;
var init_base = __esm({
  "node_modules/quill/themes/base.js"() {
    init_lodash();
    init_emitter();
    init_theme();
    init_color_picker();
    init_icon_picker();
    init_picker();
    init_tooltip();
    ALIGNS = [false, "center", "right", "justify"];
    COLORS = ["#000000", "#e60000", "#ff9900", "#ffff00", "#008a00", "#0066cc", "#9933ff", "#ffffff", "#facccc", "#ffebcc", "#ffffcc", "#cce8cc", "#cce0f5", "#ebd6ff", "#bbbbbb", "#f06666", "#ffc266", "#ffff66", "#66b966", "#66a3e0", "#c285ff", "#888888", "#a10000", "#b26b00", "#b2b200", "#006100", "#0047b2", "#6b24b2", "#444444", "#5c0000", "#663d00", "#666600", "#003700", "#002966", "#3d1466"];
    FONTS = [false, "serif", "monospace"];
    HEADERS = ["1", "2", "3", false];
    SIZES = ["small", false, "large", "huge"];
    BaseTheme = class extends theme_default {
      constructor(quill, options) {
        super(quill, options);
        const listener = (e) => {
          if (!document.body.contains(quill.root)) {
            document.body.removeEventListener("click", listener);
            return;
          }
          if (this.tooltip != null && // @ts-expect-error
          !this.tooltip.root.contains(e.target) && // @ts-expect-error
          document.activeElement !== this.tooltip.textbox && !this.quill.hasFocus()) {
            this.tooltip.hide();
          }
          if (this.pickers != null) {
            this.pickers.forEach((picker) => {
              if (!picker.container.contains(e.target)) {
                picker.close();
              }
            });
          }
        };
        quill.emitter.listenDOM("click", document.body, listener);
      }
      addModule(name) {
        const module = super.addModule(name);
        if (name === "toolbar") {
          this.extendToolbar(module);
        }
        return module;
      }
      buildButtons(buttons, icons) {
        Array.from(buttons).forEach((button) => {
          const className = button.getAttribute("class") || "";
          className.split(/\s+/).forEach((name) => {
            if (!name.startsWith("ql-")) return;
            name = name.slice("ql-".length);
            if (icons[name] == null) return;
            if (name === "direction") {
              button.innerHTML = icons[name][""] + icons[name].rtl;
            } else if (typeof icons[name] === "string") {
              button.innerHTML = icons[name];
            } else {
              const value = button.value || "";
              if (value != null && icons[name][value]) {
                button.innerHTML = icons[name][value];
              }
            }
          });
        });
      }
      buildPickers(selects, icons) {
        this.pickers = Array.from(selects).map((select) => {
          if (select.classList.contains("ql-align")) {
            if (select.querySelector("option") == null) {
              fillSelect(select, ALIGNS);
            }
            if (typeof icons.align === "object") {
              return new icon_picker_default(select, icons.align);
            }
          }
          if (select.classList.contains("ql-background") || select.classList.contains("ql-color")) {
            const format = select.classList.contains("ql-background") ? "background" : "color";
            if (select.querySelector("option") == null) {
              fillSelect(select, COLORS, format === "background" ? "#ffffff" : "#000000");
            }
            return new color_picker_default(select, icons[format]);
          }
          if (select.querySelector("option") == null) {
            if (select.classList.contains("ql-font")) {
              fillSelect(select, FONTS);
            } else if (select.classList.contains("ql-header")) {
              fillSelect(select, HEADERS);
            } else if (select.classList.contains("ql-size")) {
              fillSelect(select, SIZES);
            }
          }
          return new picker_default(select);
        });
        const update = () => {
          this.pickers.forEach((picker) => {
            picker.update();
          });
        };
        this.quill.on(emitter_default.events.EDITOR_CHANGE, update);
      }
    };
    BaseTheme.DEFAULTS = merge_default({}, theme_default.DEFAULTS, {
      modules: {
        toolbar: {
          handlers: {
            formula() {
              this.quill.theme.tooltip.edit("formula");
            },
            image() {
              let fileInput = this.container.querySelector("input.ql-image[type=file]");
              if (fileInput == null) {
                fileInput = document.createElement("input");
                fileInput.setAttribute("type", "file");
                fileInput.setAttribute("accept", this.quill.uploader.options.mimetypes.join(", "));
                fileInput.classList.add("ql-image");
                fileInput.addEventListener("change", () => {
                  const range = this.quill.getSelection(true);
                  this.quill.uploader.upload(range, fileInput.files);
                  fileInput.value = "";
                });
                this.container.appendChild(fileInput);
              }
              fileInput.click();
            },
            video() {
              this.quill.theme.tooltip.edit("video");
            }
          }
        }
      }
    });
    BaseTooltip = class extends tooltip_default {
      constructor(quill, boundsContainer) {
        super(quill, boundsContainer);
        this.textbox = this.root.querySelector('input[type="text"]');
        this.listen();
      }
      listen() {
        this.textbox.addEventListener("keydown", (event) => {
          if (event.key === "Enter") {
            this.save();
            event.preventDefault();
          } else if (event.key === "Escape") {
            this.cancel();
            event.preventDefault();
          }
        });
      }
      cancel() {
        this.hide();
        this.restoreFocus();
      }
      edit() {
        let mode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "link";
        let preview = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        this.root.classList.remove("ql-hidden");
        this.root.classList.add("ql-editing");
        if (this.textbox == null) return;
        if (preview != null) {
          this.textbox.value = preview;
        } else if (mode !== this.root.getAttribute("data-mode")) {
          this.textbox.value = "";
        }
        const bounds = this.quill.getBounds(this.quill.selection.savedRange);
        if (bounds != null) {
          this.position(bounds);
        }
        this.textbox.select();
        this.textbox.setAttribute("placeholder", this.textbox.getAttribute(`data-${mode}`) || "");
        this.root.setAttribute("data-mode", mode);
      }
      restoreFocus() {
        this.quill.focus({
          preventScroll: true
        });
      }
      save() {
        let {
          value
        } = this.textbox;
        switch (this.root.getAttribute("data-mode")) {
          case "link": {
            const {
              scrollTop
            } = this.quill.root;
            if (this.linkRange) {
              this.quill.formatText(this.linkRange, "link", value, emitter_default.sources.USER);
              delete this.linkRange;
            } else {
              this.restoreFocus();
              this.quill.format("link", value, emitter_default.sources.USER);
            }
            this.quill.root.scrollTop = scrollTop;
            break;
          }
          case "video": {
            value = extractVideoUrl(value);
          }
          // eslint-disable-next-line no-fallthrough
          case "formula": {
            if (!value) break;
            const range = this.quill.getSelection(true);
            if (range != null) {
              const index = range.index + range.length;
              this.quill.insertEmbed(
                index,
                // @ts-expect-error Fix me later
                this.root.getAttribute("data-mode"),
                value,
                emitter_default.sources.USER
              );
              if (this.root.getAttribute("data-mode") === "formula") {
                this.quill.insertText(index + 1, " ", emitter_default.sources.USER);
              }
              this.quill.setSelection(index + 2, emitter_default.sources.USER);
            }
            break;
          }
          default:
        }
        this.textbox.value = "";
        this.hide();
      }
    };
  }
});

// node_modules/quill/themes/bubble.js
var TOOLBAR_CONFIG, BubbleTooltip, BubbleTheme;
var init_bubble = __esm({
  "node_modules/quill/themes/bubble.js"() {
    init_lodash();
    init_emitter();
    init_base();
    init_selection();
    init_icons();
    init_quill();
    TOOLBAR_CONFIG = [["bold", "italic", "link"], [{
      header: 1
    }, {
      header: 2
    }, "blockquote"]];
    BubbleTooltip = class extends BaseTooltip {
      constructor(quill, bounds) {
        super(quill, bounds);
        this.quill.on(emitter_default.events.EDITOR_CHANGE, (type, range, oldRange, source) => {
          if (type !== emitter_default.events.SELECTION_CHANGE) return;
          if (range != null && range.length > 0 && source === emitter_default.sources.USER) {
            this.show();
            this.root.style.left = "0px";
            this.root.style.width = "";
            this.root.style.width = `${this.root.offsetWidth}px`;
            const lines = this.quill.getLines(range.index, range.length);
            if (lines.length === 1) {
              const bounds2 = this.quill.getBounds(range);
              if (bounds2 != null) {
                this.position(bounds2);
              }
            } else {
              const lastLine = lines[lines.length - 1];
              const index = this.quill.getIndex(lastLine);
              const length = Math.min(lastLine.length() - 1, range.index + range.length - index);
              const indexBounds = this.quill.getBounds(new Range(index, length));
              if (indexBounds != null) {
                this.position(indexBounds);
              }
            }
          } else if (document.activeElement !== this.textbox && this.quill.hasFocus()) {
            this.hide();
          }
        });
      }
      listen() {
        super.listen();
        this.root.querySelector(".ql-close").addEventListener("click", () => {
          this.root.classList.remove("ql-editing");
        });
        this.quill.on(emitter_default.events.SCROLL_OPTIMIZE, () => {
          setTimeout(() => {
            if (this.root.classList.contains("ql-hidden")) return;
            const range = this.quill.getSelection();
            if (range != null) {
              const bounds = this.quill.getBounds(range);
              if (bounds != null) {
                this.position(bounds);
              }
            }
          }, 1);
        });
      }
      cancel() {
        this.show();
      }
      position(reference) {
        const shift = super.position(reference);
        const arrow = this.root.querySelector(".ql-tooltip-arrow");
        arrow.style.marginLeft = "";
        if (shift !== 0) {
          arrow.style.marginLeft = `${-1 * shift - arrow.offsetWidth / 2}px`;
        }
        return shift;
      }
    };
    __publicField(BubbleTooltip, "TEMPLATE", ['<span class="ql-tooltip-arrow"></span>', '<div class="ql-tooltip-editor">', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-close"></a>', "</div>"].join(""));
    BubbleTheme = class extends BaseTheme {
      constructor(quill, options) {
        if (options.modules.toolbar != null && options.modules.toolbar.container == null) {
          options.modules.toolbar.container = TOOLBAR_CONFIG;
        }
        super(quill, options);
        this.quill.container.classList.add("ql-bubble");
      }
      extendToolbar(toolbar) {
        this.tooltip = new BubbleTooltip(this.quill, this.options.bounds);
        if (toolbar.container != null) {
          this.tooltip.root.appendChild(toolbar.container);
          this.buildButtons(toolbar.container.querySelectorAll("button"), icons_default);
          this.buildPickers(toolbar.container.querySelectorAll("select"), icons_default);
        }
      }
    };
    BubbleTheme.DEFAULTS = merge_default({}, BaseTheme.DEFAULTS, {
      modules: {
        toolbar: {
          handlers: {
            link(value) {
              if (!value) {
                this.quill.format("link", false, Quill.sources.USER);
              } else {
                this.quill.theme.tooltip.edit();
              }
            }
          }
        }
      }
    });
  }
});

// node_modules/quill/themes/snow.js
var TOOLBAR_CONFIG2, SnowTooltip, SnowTheme, snow_default;
var init_snow = __esm({
  "node_modules/quill/themes/snow.js"() {
    init_lodash();
    init_emitter();
    init_base();
    init_link();
    init_selection();
    init_icons();
    init_quill();
    TOOLBAR_CONFIG2 = [[{
      header: ["1", "2", "3", false]
    }], ["bold", "italic", "underline", "link"], [{
      list: "ordered"
    }, {
      list: "bullet"
    }], ["clean"]];
    SnowTooltip = class extends BaseTooltip {
      constructor() {
        super(...arguments);
        __publicField(this, "preview", this.root.querySelector("a.ql-preview"));
      }
      listen() {
        super.listen();
        this.root.querySelector("a.ql-action").addEventListener("click", (event) => {
          if (this.root.classList.contains("ql-editing")) {
            this.save();
          } else {
            this.edit("link", this.preview.textContent);
          }
          event.preventDefault();
        });
        this.root.querySelector("a.ql-remove").addEventListener("click", (event) => {
          if (this.linkRange != null) {
            const range = this.linkRange;
            this.restoreFocus();
            this.quill.formatText(range, "link", false, emitter_default.sources.USER);
            delete this.linkRange;
          }
          event.preventDefault();
          this.hide();
        });
        this.quill.on(emitter_default.events.SELECTION_CHANGE, (range, oldRange, source) => {
          if (range == null) return;
          if (range.length === 0 && source === emitter_default.sources.USER) {
            const [link, offset] = this.quill.scroll.descendant(Link, range.index);
            if (link != null) {
              this.linkRange = new Range(range.index - offset, link.length());
              const preview = Link.formats(link.domNode);
              this.preview.textContent = preview;
              this.preview.setAttribute("href", preview);
              this.show();
              const bounds = this.quill.getBounds(this.linkRange);
              if (bounds != null) {
                this.position(bounds);
              }
              return;
            }
          } else {
            delete this.linkRange;
          }
          this.hide();
        });
      }
      show() {
        super.show();
        this.root.removeAttribute("data-mode");
      }
    };
    __publicField(SnowTooltip, "TEMPLATE", ['<a class="ql-preview" rel="noopener noreferrer" target="_blank" href="about:blank"></a>', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-action"></a>', '<a class="ql-remove"></a>'].join(""));
    SnowTheme = class extends BaseTheme {
      constructor(quill, options) {
        if (options.modules.toolbar != null && options.modules.toolbar.container == null) {
          options.modules.toolbar.container = TOOLBAR_CONFIG2;
        }
        super(quill, options);
        this.quill.container.classList.add("ql-snow");
      }
      extendToolbar(toolbar) {
        if (toolbar.container != null) {
          toolbar.container.classList.add("ql-snow");
          this.buildButtons(toolbar.container.querySelectorAll("button"), icons_default);
          this.buildPickers(toolbar.container.querySelectorAll("select"), icons_default);
          this.tooltip = new SnowTooltip(this.quill, this.options.bounds);
          if (toolbar.container.querySelector(".ql-link")) {
            this.quill.keyboard.addBinding({
              key: "k",
              shortKey: true
            }, (_range, context) => {
              toolbar.handlers.link.call(toolbar, !context.format.link);
            });
          }
        }
      }
    };
    SnowTheme.DEFAULTS = merge_default({}, BaseTheme.DEFAULTS, {
      modules: {
        toolbar: {
          handlers: {
            link(value) {
              if (value) {
                const range = this.quill.getSelection();
                if (range == null || range.length === 0) return;
                let preview = this.quill.getText(range);
                if (/^\S+@\S+\.\S+$/.test(preview) && preview.indexOf("mailto:") !== 0) {
                  preview = `mailto:${preview}`;
                }
                const {
                  tooltip
                } = this.quill.theme;
                tooltip.edit("link", preview);
              } else {
                this.quill.format("link", false, Quill.sources.USER);
              }
            }
          }
        }
      }
    });
    snow_default = SnowTheme;
  }
});

// node_modules/quill/quill.js
var quill_exports = {};
__export(quill_exports, {
  AttributeMap: () => import_quill_delta6.AttributeMap,
  Delta: () => import_quill_delta6.default,
  Module: () => module_default,
  Op: () => import_quill_delta6.Op,
  OpIterator: () => import_quill_delta6.OpIterator,
  Parchment: () => parchment_exports,
  Range: () => Range,
  default: () => quill_default
});
var quill_default;
var init_quill2 = __esm({
  "node_modules/quill/quill.js"() {
    init_core();
    init_align();
    init_direction();
    init_indent();
    init_blockquote();
    init_header();
    init_list();
    init_background();
    init_color();
    init_font();
    init_size();
    init_bold();
    init_italic();
    init_link();
    init_script();
    init_strike();
    init_underline();
    init_formula();
    init_image();
    init_video();
    init_code();
    init_syntax();
    init_table();
    init_toolbar();
    init_icons();
    init_picker();
    init_color_picker();
    init_icon_picker();
    init_tooltip();
    init_bubble();
    init_snow();
    init_core();
    core_default.register({
      "attributors/attribute/direction": DirectionAttribute,
      "attributors/class/align": AlignClass,
      "attributors/class/background": BackgroundClass,
      "attributors/class/color": ColorClass,
      "attributors/class/direction": DirectionClass,
      "attributors/class/font": FontClass,
      "attributors/class/size": SizeClass,
      "attributors/style/align": AlignStyle,
      "attributors/style/background": BackgroundStyle,
      "attributors/style/color": ColorStyle,
      "attributors/style/direction": DirectionStyle,
      "attributors/style/font": FontStyle,
      "attributors/style/size": SizeStyle
    }, true);
    core_default.register({
      "formats/align": AlignClass,
      "formats/direction": DirectionClass,
      "formats/indent": indent_default,
      "formats/background": BackgroundStyle,
      "formats/color": ColorStyle,
      "formats/font": FontClass,
      "formats/size": SizeClass,
      "formats/blockquote": blockquote_default,
      "formats/code-block": CodeBlock,
      "formats/header": header_default,
      "formats/list": ListItem,
      "formats/bold": bold_default,
      "formats/code": Code,
      "formats/italic": italic_default,
      "formats/link": Link,
      "formats/script": script_default,
      "formats/strike": strike_default,
      "formats/underline": underline_default,
      "formats/formula": formula_default,
      "formats/image": image_default,
      "formats/video": video_default,
      "modules/syntax": Syntax,
      "modules/table": table_default,
      "modules/toolbar": Toolbar,
      "themes/bubble": BubbleTheme,
      "themes/snow": snow_default,
      "ui/icons": icons_default,
      "ui/picker": picker_default,
      "ui/icon-picker": icon_picker_default,
      "ui/color-picker": color_picker_default,
      "ui/tooltip": tooltip_default
    }, true);
    quill_default = core_default;
  }
});

export {
  import_quill_delta6 as import_quill_delta,
  quill_default,
  quill_exports,
  init_quill2 as init_quill
};
//# sourceMappingURL=chunk-PPEJB6Y4.js.map
